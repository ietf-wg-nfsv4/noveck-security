<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="6"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std"
     docName="draft-dnoveck-nfsv4-security-08" indexInclude="true"
     ipr="pre5378Trust200902" updates="8881,7530" scripts="Common,Latin"
     sortRefs="false" submissionType="IETF" 
     tocDepth="3" tocInclude="true" xml:lang="en">
  <front>
    <title abbrev="Nfsv4 Security">Security for the NFSv4 Protocols</title>
    <author fullname="David Noveck" initials="D." surname="Noveck" role="editor">
      <organization abbrev="NetApp">NetApp</organization>
      <address>
        <postal>
          <street>201 Jones Road, Suite 16</street>
          <city>Waltham</city>
          <region>MA</region>
          <code>02451</code>
          <country>United States of America</country>
        </postal>
        <phone>+1-781-572-8038</phone>
        <email>davenoveck@gmail.com</email>
      </address>
    </author>
    <date year="2024"/>
    <area>Transport</area>
    <workgroup>NFSv4</workgroup>
    <keyword>example</keyword>
    <abstract>
      <t>
	This document describes the core security features of the NFSv4
	family of protocols, applying to all minor versions. The discussion
	includes the use of security features provided by RPC on a
	per-connection basis.  Important aspects of the authorization
	model, related to the ACL feature, will be specified in a
	separate document.
      </t>
      <t>
	The current version of the document is intended, in
	large part, to result in working group discussion
	regarding existing NFSv4 security issues and to provide
	a framework for addressing these issues and obtaining
	working group consensus regarding necessary changes.
      </t>
      <t>
        When the resulting documents (i.e. this document and one derived
	from the separate ACL specification) are eventually published as
	RFCs,
	they will, by updating these documents, supersede the
	description of
	security appearing in existing minor version specification
	documents such as RFC 7530 and RFC 8881, 
      </t>
    </abstract>
  </front>
  <middle>
  <section anchor="OVIEW">
    <name>Overview</name>
      <t>
	These documents, including this document and the companion ACL
	document <xref target="I-D.dnoveck-nfsv4-acls"/>, are
	intended to form the basis for a new
	description of NFSv4 security applying to all
	NFSv4 minor versions. The motivation for these new documents and
	the need for major improvements in the description of NFSv4 security
	are explained
	in <xref target="OVIEW-motive"/>. 
      </t>
      <t>
	Because these documents anticipate making major changes in material
	covered in previous standards-track RFCs, extensive working group
	discussion will be necessary to make sure that there is a working
	group consensus to make the changes being  proposed.  The
	changes needed include the major improvements mentioned in
	<xref target="OVIEW-motive-orig"/> and the
	changes necessary to suitably describe features currently 
	described in a way that is inappropriate in Standards Track
	documents, for reasons laid out in <xref target="UINTRO-needwork"/>.
	A large part of the material necessary to accomplish this
	set of goals will appear in
	<xref target="I-D.dnoveck-nfsv4-acls"/> and its
	successors.
      </t>
      <t>
	The need to make major changes in the security approach for three
	Proposed Standards (<xref target="RFC7530"/> for NFSv4.0,
	<xref target="RFC8881"/> for NFSv4.1, and
	<xref target="RFC7862"/> for NFSv4.2) raises troubling issues.
	These changes are necessary for reasons explained
	in <xref target="OVIEW-motive"/>.
	These troubling issues often concern compatibility and compliance
	issues as described in <xref target="OVIEW-compat"/>. 
      </t>
      <section anchor="OVIEW-motive">
        <name>Document Motivation</name>

	<section anchor="OVIEW-motive-orig">
          <name>Original Motivation</name>
        <t> 
          A new treatment of security is necessary because:
	</t>  
	<ul>
	  <li><t>
	    Previous treatments paid insufficient attention to security
	    issues regarding data in flight, assuming that security could
	    reasonably be provided on an  optional basis, to secure
	    particular portions of the server namespace.
	  </t></li>
	  <li><t>
	    The presentation of AUTH_SYS as an "<bcp14>OPTIONAL</bcp14>
	    means of authentication" obscured the significant security
	    problems that come with its use.
	  </t></li>
	  <li><t>
	    The security considerations sections of existing minor
	    version specifications contain no threat analyses and
	    focus on particular security issues in a way that obscures,
	    rather than clarifying, the issues that need to
	    be addressed, while implying, often incorrectly, that the
	    existing security features are adequate to the need.
	  </t></li>
	  <li><t>
	    The availability of connection-oriented RPC security features,
	    such as those provided by RPC-with-TLS (described in
	    <xref target="RFC9289"/>) provides
	    facilities that NFSv4 clients and servers will need to
	    use to provide security for data in flight and mitigate
	    the lack of user authentication when AUTH_SYS is used.
	  </t></li>
	</ul>
	</section>
	<section anchor="OVIEW-motive-acl">
          <name>Need for Respecifcation of Acl-related Funtionality</name>

	  <t>
	    Review of the existing specifications has made it apparent that
	    the handling of ACLs has not been described in the detail normally
	    necessary to
	    make it possible to implement interoperating clients and servers.
	    Because of the broad
	    license granted by previous specifications to allow
	    server implementations
	    to choose how to behave, clients are forced to accept a broad
	    range of server behaviors, with no way of reliably determining
	    the server behavior actually implemented.
	  </t>
      <t>
	One important reason that such extensive changes are now
	necessary derives
	from a disagreement among working group partucipants as to
	the purpose
	of ACL support with one group of participants requiring new
	functionallity matching
	that of Windows ACLs with another major group uninterested in such
	features and unwilling to devote the effort involved in providing
	server-side support for them.
      </t>
      <t>
	Within the NFSv4 architecture, such situations are normally
	dealt by defining
	one or more optional features, allowing different servers to provide
	different levels of support, with the client able to determine whether
	a selected server has the desired level of support.
      </t>
      <t>
	Unfortunately, for reasons that remain unclear, this approach was not
	followed in writing RFCs 3530, 5661, 7530, and 8881.  Instead, the full
	definition of the ACL was defined as an OPTIONAL attribute with no
	clear definition of useful support subsets or way of testing the
	support level.  Essentially, each ACE mask bit was made its own optional
	feature.   To further complicate things, the keyword "<bcp14>SHOULD
	</bcp14>" was frequently used, raising the possibility that
	the support might
	be other than described.  This made it impossible for
	clients to determine the level of ACL suppport provided, or to
	choose whether to use a server based on the level of support provided.
      </t>
      <t>
	As a result, we now need to provide a core ACL model that all
	clients can rely
	upon while providing the ability for server to implement useful
	extensions.  This work will done within the companion document
	devoted to ACLs <xref target="I-D.dnoveck-nfsv4-acls"/>.
	Given the need to thorougly revise the discussion of ACLs while
	avoiding prohibited XDR changes and troublesome implementation
	incompatibilities, the working group will need information about
	implementations of the vast range of possibilities allowed,
	inadvertantly or not, by previous treatments of the matter. 
      </t>
	  
        <t>
	  In view of these difficulties in the existing specification
	  of acl-related semantics a new approach toward the specfication
	  will be adopted in
	  <xref target="I-D.dnoveck-nfsv4-acls"/> and its
	  successors, although the goal, of allowing a range of potential
	  ACL implementations, will remain the same, as will the XDR used to
	  represent the
	  relevant protocol elments.  This XDR encompasses many <bcp14>
	  OPTIONAL</bcp14> extensions to the UNIX ACLs whose core
	  semantics need to be supported by all servers supporting ACLs.
	</t>
      </section>
	<section anchor="OVIEW-motive-later">
          <name>Further Issues that Neeed to be Addressed</name>
            <t>
	      As work has proceeded, additional important issues were
	      discovered.  Of prime importantce are following issues
	      relateed to the classification of attributes:
	    </t>
	    <ul>
	      <li><t>
		The attributes Owner, Owner_group, and Mode
		needed to be made <bcp14>REQUIRED</bcp14> since
		clients need this information and not supporting
		these attributes would create troublesome
		interoperabiity issues.
	      </t><t>
	        Previous specifications explicitly allowed servers
	        to support none of these
	        and even discussed a supposed need to support use of
		servers that
		supported none of the above attributes and none of the
		acl-related attributes either.  To continue in this
		way would ovecomplicate the specification and create
		difficult interoperability issues to support
		implementations that have little practical purpose.
	      </t></li>
	      <li><t>
		The change in the format of specification of user ids and
		group ids, made as part of transition from NFSv3 to NFSv4,
		requires significant modification, in order to adddress
		a serious underspecification that creates the possbility
		of addditional
		security vulnerablities.
	      </t><t>
	        The change to a string-format representaion of thse ids was
	        intended to provide a way to allow the protocol to escape
		the restrictions inherent in the previous representaion of
		these ids by 32-bit unsigned integers.    However, as things
		have developed, for practical puposes,
		these restrictions remain in effect since
		the associated ids within POSIX are still 32-bit unsigned
		integers and the working group has no way of prompting 
		changes necessary to implememt a more flexible approach..
	      </t><t>
                While the use of ids of the form "name@domain" might
	        help achieve the original goal if used together with multiple
		domains, that would require server support to sumultenously
		support multiple Kerberos realms, not yet available.
	      </t><t>
	        In the case in which AUTH_SYS is used, there is no reliable
	        way to effect the mapping betweeen names and numeric ids.
		In the existing specfications, the provision of this mapping
		is treated as an implementation matter without protocol
		support.  This has proved unacceptable becasue any
		implementation advice would require compatible implementationss
		on the client and server, and would allow attacks via
		interferance with the mapping.   Although use of numerc
		ids instead is possible, it has been unfairly stigmatized
		in previous specifications, with the suggestion made
		that use of numeric strings somehow compromises the
		orignal intent of the shift, which nevertheless, is in no
		way undercut by the use of strings having numeric values as
		long as the "name@domain" format is still available
		when useful and
		necessary.
	      </t><t>
	        In the new treatment (in <xref target="ATTR-idstrings"/>),
		the mapping between name and numeric ids is the responsibility
		of Kerberos and the use
		of numeric strings is available for the AUTH_SYS case,
		avoiding any need for mapping between names and numeric ids
		in this common case.  In order to accommodte pevious
		implemntations, such mapping is allowed, although it creates
		some unfortunate security vulnerabilities that are best
		avoided.
	      </t></li>
        </ul>
	
	<t>
	  In addition to these two major issues, the following other
	  issues were found and needed to be addressed in this document:
	</t>
	<ul>
	  <li><t>
	    Although involved in the inadequate speecification of
	    ACL handling,
	    a separate source of
	    issues that need to be addressed involves use of the term
	    "<bcp14>SHOULD</bcp14>", sometimes
	    meaning "should" and sometimes meaning <bcp14>MAY</bcp14>,
            but never including discussion of the harm caued by not
            follwing the recommendation, or a discussion of what 
	    might be valid reasons to ignore the recommendation.
 	  </t></li>
	  <li><t>
	    The discussion of handling of modes is limited to
	    forward-slope modes and ignores the possibility of
	    reverse-slope modes.
	  </t><t>
	    For definitions of these terms, see
	    <xref target="INTRO-term"/>.   
	  </t><t>
            For examlles of the necessary changes, see Sections
	    ACLSPEC(AUTHCOMB-computemode)
	    and ACLSPEC(AUTHCOMB-setmode).
	  </t></li>
	  <li><t>
	    There are a number of claarifications/corrections
	    to the description of ACE mask bits appearing in
	    ACLSPEC(ACE-maskd).
	  </t></li>
	</ul>       
	</section>
      </section>
      <section anchor="OVIEW-notation">
        <name>Document Annotation</name>
	<t>
	  In order to make progress on difficult issues which will require
	  that changes be made in the existing handling of security issues,
	  including many whose resolution would potentially involve
	  compatibility
	  issues with existing implementations, the author has
	  tried his best to resolve these issues, even though there is no
	  assurance that the resolution adopted by consensus will match the
	  author's current best efforts.  To provide possible resolutions
	  that might be the basis of discussion while not foreclosing other
	  possibilities, proposed changes are organized into a series of
	  consensus items, which are listed in <xref target="ISSUES"/>
	  and in a corresponding Appendix in the acl document.
	</t>
	<t>
	  For such pending issues, the
	  following annotations will be used:
	</t>
	<ul>
	  <li><t>
	    A paragraph headed "[Author Aside]:", provides the author's
	    comments about possible changes and will probably not appear
	    in an eventual RFC.
	  </t><t>
	    This paragraph can specify that certain changes within
	    the current section are to be implicitly considered as
	    part of a specific consensus item.
	  </t><t>
	    The paragraph can indicate that all unannotated material in
	    the current section is to be considered either the previous
	    treatment or the proposed replacement text for a specific
	    consensus item.   
	  </t></li>
	  <li><t>
	    A paragraph headed "[Consensus Needed (Item #NNx)]:",
	    provides the author's
	    preferred treatment of the matter and will only appear in the
	    eventual RFC if working group consensus on the matter is
	    obtained, allowing the necessary changes to be made permanent,
	    without being conditional on a future consensus.
	  </t><t>
	    The item id, represented above by "NNx" consists of a number
	    identifying  the specific consensus item and letter which is
	    unique to appearance of that consensus item in a particular
	    section. In cases in which a pending item is cited with no
	    part of the discussion appearing in the current section,
	    an item id of the form "#NN" is used.
	  </t></li>
	  <li><t>
	    A paragraph headed "[Previous Treatment]:", indicates text that
	    is provided for context but which the author believes, need
	    not appear in the eventual RFC, because it is expected to
	    be superseded by a corresponding consensus item.
	  </t><t>
	    The corresponding consensus item is often easily inferred, but
	    can be specified explicitly, as it is for items associated
	    with the
	    consensus item itself.
	  </t></li>
	</ul>
	<t>
	  Each of the annotations above can be modified by addition of the
	  phrase, "Including List" to indicate that it applies to a following
	  bulleted list as well as the current paragraph or the phase
	  "Entire Bulleted Item" to indicate it applies to all paragraphs
	  within a specific bulleted item.
	</t>
      </section>
      <section anchor="OVIEW-compat">
        <name>Compatibility and Compliance Issues</name>
	<t>
	  Changes that need to be adopted in this document might need to
	  eventually
	  change the behavior of clients and servers that were written
	  to conform to earlier protocol specifications.  There are two
	  important classes of such changes discussed in Sections
	  <xref target="OVIEW-compat-mistake" format="counter"/> and
	  <xref target="OVIEW-compat-uncertain" format="counter"/>
	  below.
        </t>
	<t>
	  As <xref target="RFC2119"/> was originally conceived,
	  compliance and compatibility issues were tightly bound
	  together so that a change to compliance specifications would
	  inevitably give rise to compatibility issues.  However, over
	  time, behaviors have come to be denigrated by use of the terms
	  "<bcp14>SHOULD NOT</bcp14>" and "<bcp14>MUST NOT</bcp14>"
	  to warn implementors of a harm deriving from from insecure operation
	  rather than peer incompatibility.
	</t>
        
        <t>
	  When making changes in compliance requirements/recommendations we
	  need to deal with the possibility that,
	  in changing the specification, we might cause a previously
	  compliant implementation to become non-compliant.  Some
	  implementers take the view that the compliance status of their
	  implementations is of less importance than other considerations
	  such as compatibility with local file system semantics.  Others
	  feel it is important to maintain the compliance status of existing
	  implementations.  In any case, the working group has been reluctant,
	  when making such necessary changes, to make previously compliant
	  implementations non-compliant, and will try not to do in cases
	  in which it is known or can reasonably be expected that
	  such implementations exist.
        </t>
	<t>
	  Although there is no way to be sure about the non-existence
	  of such implementations, the working group has made judgments
	  about what implementations are likely to exist.  For example,
	  when internationalization for NFSv4.0 was changed in the transition
	  to 
	  <xref target="RFC7530"/>, many previously non-compliant
	  server implementations became officially compliant and
	  there was a potential
	  for conflict with implementations compliant with RFC3530
	  <xref target="RFC3530"/>, if any such implementations existed. 
        </t>
        <t>
	  In that particular case, it was decided that no such
	  RFC3530-compliant server implementations existed and there was
	  no need to accommodate servers whose internationalization
	  was written to conform to <xref target="RFC3530"/> since
	  no such servers existed and there were no client implementations
	  expecting such behavior.   As a result, no actual implementations
	  became non-compliant as a result of this necessary shift.
        </t>
        <t>
	  In the corresponding cases dealt with in this document, the situation
	  is more difficult since it may be harder to determine the
	  actual behavior of all existing implementations, since the authors
	  might no longer be actively involved with implementation issues.
	  However, it will be necessary to warn implementors
	  of the negative consequences of certain behaviors without going so far
	  as to declare these practices non-compliant.  For the most part, this
	  document will use the terms "<bcp14>SHOULD</bcp14>" and
	  "<bcp14>SHOULD NOT</bcp14>" to draw attention to the problems with
	  troublesome behaviors that previous specifications mentioned
	  with no indication of the problems with them.  In such contexts,
	  it is made clear that the need to maintain existing patterns of
	  interoperation is a valid reason to bypass the normative term.  The
	  intention is to continue to allow previously acceptable
	  implementations to be considered compliant while not placing the
	  troublesome behaviors on the same levels as other alternatives
	  as would happen if we used the terms
	  "<bcp14>MAY</bcp14>" or "<bcp14>OPTIONAL</bcp14>" or continued
	  to use some
	  of the unfortunate practices discussed in
	  <xref target="OVIEW-compat-uncertain"/>.
	</t>
	<t>
	  This approach allows implementations to accept input from peers
	  written in accord with previous specification while not obligating
	  them to do so.  The intent is to allow a transition to newer, better
	  behaviors over time as client and server policies evolve.   However,
	  the specifics of this anticipated transition will vary:
	</t>
	<ul>
	  <li><t>
	    In the case of the issues dealt with in
	    <xref target="OVIEW-compat-mistake"/>, the focus is on making
	    implementers aware of the security problems with practices
	    previously considered acceptable.
	  </t><t>
	    It is specified that these
	    practices <bcp14>SHOULD NOT</bcp14> be used by clients or allowed
	    by servers in order to draw attention
	    to the security problems with them.  At the same time, the
	    discussion of valid reasons to bypass these recommendations
	    allows them to continue
	    to be used while the infrastructure is developed to make their
	    replacements easy to use.
	  </t><t>
            Servers are encouraged to adopt policies foreclosing client use
 	    but not obligated to do so.
	  </t></li>
	  <li><t>
	    In the case of the issues dealt with in
	    <xref target="OVIEW-compat-uncertain"/>, the focus is different.
	    In these cases, while we anticipate making changes in
	    compliance specifications, there is no need to address a specific
	    set of troublesome practices.  Instead, the problem to be
	    addressed is the
	    vast range of allowable server behaviors previously defined as
	    allowed, although not necessarily explicitly.
	    This server-centered approach has made compatibility a hit-or-miss
	    matter, requiring serious consideration of the question of what
	    specific instances of multiple server behaviors need to be allowed
	    and how clients can find out the choices that servers have made
	    and possibly affect them, also making appropriate provision, as
	    with other optional features, about how to adapt to the server's
	    behavioral choices or to decide that they do not meet its needs.
	  </t><t>
	    It appears that this approach was motivated, at least in large
	    part, by the desire to fully support much of Windows ACL
	    semantics while accommodating Unix servers incapable of
	    providing much of that functionality.  As a result, the working
	    group will need to provide a way for the server to explicitly
	    opt out of providing Windows functionality that it cannot provide
	    and that Linux clients are not prepared to use.
	  </t><t>
	    In addition, the working group will have to restrict, or at
	    least better organize, sever behavioral choices related to the
	    handling of ACLs.
	  </t>
	  </li>
	</ul>

      <section anchor="OVIEW-compat-mistake">
        <name>Dealing with Recognized Mistakes</name>
	<t>
	  As an example, we consider the handling of AUTH_SYS (presumably
	  in the clear, without client peer authentication), described in
	  previous specifications as
	  "<bcp14>OPTIONAL</bcp14>".   While the authors might have only
	  been indicating that servers could choose not to support it,
	  and that clients had to be prepared for it not to be supported
	  by the server, the likely import of this designation, for
	  clients, was to indicate to implementers that they could choose
	  to use
	  AUTH_SYS and that the authors of the spec were, by not
	  recommending otherwise, as we might now feel they should have 
	  done, indicating there there were no issues whereby using AUTH_SYS
	  in this form had the capacity to cause harm.  As a result, clients
	  using AUTH_SYS in this way were to be considered specification-
	  compliant and were not warned of the real security issues
	  created by this use.
	</t>
	<t>
	  As the protocol was implemented and further developed in
	  subsequent minor versions, the specifications, which had
	  Security Considerations sections that did not contain threat
	  analyses, had no place to indicate to users and implementers
	  of NFSv4 the security problems that come with AUTH_SYS use and
	  it continued to be used heavily while encryption was only
	  available to clients using RPCSEC_GSS and left as a choice that
	  was not frequently used, despite the security issues that this
	  raised.
	</t>
	<t>
	  We are now at a point at which we have to recognize that a
	  mistake was made in this regard and have to be clear about the
	  security issues present in many common implementations of the
	  protocol.   As we seek to do this, it is important to understand
	  the compliance effects of doing so.  This document, when adopted, will
	  supersede previous specifications which took a different approach.
	  Although it might, given the security issues
	  with AUTH_SYS, make sense to say that it "<bcp14>MUST NOT</bcp14>"
	  be used in that way, the working group is very reluctant
	  to retroactively declare previously compliant behavior
	  non-compliant, even in this case where there is good reason to
	  do so.   A more likely approach is to say that clients
	  "<bcp14>SHOULD NOT</bcp14>" do this while making it clear that
	  the difficulty
	  of changing existing implementations and potential compatibility
	  with existing peers are valid reasons to bypass
	  the recommendation.
	  Servers are, as before, allowed to support AUTH_SYS but
	  "<bcp14>SHOULD</bcp14>" only do so when using additional
	  security facilities that make this safe. The effect would be to
	  create a clear set of recommendations to new implementations
	  while providing for continued use of previously compliant
	  implementations to continue as needed,
	</t>
	<t>
	  This approach gives rise to compatibility issues, but leaves them
	  to implementors and users to resolve, while making clear the
	  security issues with the old approach.
	</t>
      </section>
      <section anchor="OVIEW-compat-uncertain">
        <name>Dealing with Pervasive Uncertainty</name>
	<t>
	  Addressing the issues described in <xref target="UINTRO-needwork"/>
	  raises similar issues.  In this case as well, we will 
	  need to make changes in implementation behavior going forward
	  and try to do so without declaring
	  existing behavior non-compliant.   However, we cannot, as we did
	  in the example above, identify a specific set of bad choices,
	  and try to come up with replacements, that reflect our new
	  understanding of security issues.
	</t>
	<t>
	  In this case, it is necessary, as has been done in 
	  other cases in which NFSv4 tried to accommodate the needs of both
	  UNIX and Windows, to decide what part of the non-UNIX
	  semantics is required and which part is an optional extension,
	  which UNIX-oriented clients would not use and UNIX-oriented
	  servers might not support.   When this sort of issue is not
	  given the attention it needs, problems can result, although
	  the nature and severity of the problems depend on the specifics of
	  feature.
	</t>
	<t>
	  In the case of byte-range locks, severs were given a choice
	  as to implement byte-range locks in an advisory or mandatory
	  fashion.  Although servers could choose to do either, there
	  was no way for a client to determine which of these two
	  incompatible semantic models the server implemented.  As a result,
	  unix-based clients and applications assumed the advisory model
	  and could not interoperate successfully with servers implementing
	  the mandatory model.  Applications requiring mandatory semantics
	  could only interoperate with a small set of servers which chose
	  to support the mandatory model that has very few users.  The normal
	  way of dealing with situations like this is to make the server's
	  behavioral choice available to
	  the client as an attribute, as is provded for in
	  <xref target="RFC8178"/>   
	</t>
	<t>
	  In the case of ACLs, we have a difficult situation to resolve.
	  Instead of having a small set of individual mistakes
	  which can now be recognized as such, we have a situation in which
	  the existing specifications have created an unacceptable
	  interoperability situation in relation to ACL
	  implementations.  Existing
	  specifications have not paid proper attention to the need to make
	  decisions in the face of disagreements regarding proper server
	  behavior and have in various ways
	  avoided the need to compromise and reach a reasonable consensus
	  but instead have made it the job of the specifications
	  to consider valid any remotely similar server implementations as
	  valid, leaving clients little that could do other than to accept 
          a wide range of server behavior as valid, simply because it was
	  chosend by the server.
	</t>
	<t>
	  The working group did not provide any definition of a
	  restricted level of ACL support that Unix servers could provide
	  and that would address the needs of Unix clients. Instead, only
	  definition of ACL support was one that met the needs of Windows
	  clients while providing a large set of facilities that did not
	  fit within ACL needs of Unix systems.
	</t>
	<t>
	  As it became clear that considerable pieces of the
	  ACL functionality were only of value to Windows clients and
	  were 
	  difficult to provide on Unix servers, the
	  working group declined to draw that line but instead haphazardly
	  opened the
	  spec to a wide variety of possible server behaviors by the following
	  methods:
	</t>
	<ul>
	  <li><t>
	    Essentially made each ACL mask bit its own optional feature
	    with each server free to choose to implement that bit or not.	
	    Unfortunately, unlike most cases in which an optional
	    feature is provided for, there was no means for the client
	    to find out whether the server provided support a for particular
	    mask bit or, if it did not, how it dealt with authorizations
	    normally controlled by that mask bit.
	  </t></li>
	  <li><t>
	    Similarly, made all ACL flags essentially optional.
	  </t><t>
	    This was done, as in the case above, without using the terms
	    "<bcp14>OPTIONAL</bcp14>" or "<bcp14>MAY</bcp14>" which might
	    have suggested the need to provide a means for clients to find
	    out about the choices that servers were allowed to make.
	  </t></li>
	  <li><t>
	    Used "<bcp14>SHOULD</bcp14>" in situations in which it was
	    not clear why the term was used and possible to determine
	    what might be considered valid
	    reasons to bypass the recommendation.
	  </t><t>
	    Since clients have no means to find out whether these unspecified
	    reasons apply, they find themselves in a position similar the one
	    that would exist if "<bcp14>MAY</bcp14>"  were used.
	  </t><t>
	    Again a range of server behavior was allowed without any analysis
	    of the question of whether allowing such variability was
	    necessary, its effect on client interoperability, or how the
	    client might find out about the server's choices.
	  </t></li>
	  <li><t>
	    While building many aspects of the interactions of the mode
	    attribute and ACLs around a mapping from ACLs to modes, the
	    existing specifications allowed at least two different such
	    mappings to be used, creating a difficult interoperability
	    situation for clients.
	  </t><t>
	    The preferred mapping is introduced using "<bcp14>SHOULD</bcp14>",
	    again being unclear about possible reasons to bypass the
	    recommendation,
	    if that is what it is. It is sometimes stated that the use of
	    "<bcp14>SHOULD</bcp14>" is "intentional", leaving one
	    to wonder how to deal with the presumably unintentional uses of
	    "<bcp14>SHOULD</bcp14>".
          </t><t>
	    Although, it is claimed that the intention was "to avoid
            invalidating existing implementations that compute the
	    mode according to the withdrawn POSIX ACL draft (1003.1e
	    draft 17)", it is unclear how this choice relates to the
	    working group's decision to base NFSv4 ACL on Windows ACLs
	    rather than on the withdrawn POSIX draft ACLs.  It is possible
	    that there were different opinions on the proper mapping and that,
	    instead of resolving the issue, the working group avoided the
	    need to resolve this disagreement, by simply allowing
	    both methods, ignoring the effect on interoperability.
          </t><t>
	    The effect of "invalidating " such implementations would be
	    to make it clear that they are implementations of a different sort
	    of ACL, rather then of the NFSv4 ACL model, adopted by the working
	    group.  Instead, the specification allowed for many possible
	    hybrids of both models.
          </t><t>
	    A case can be made that clients, who often support only
	    ACL-related APIs based on the Unix ACL model are entitled
	    to matching ACL support, but the hybrid approach adopted makes no
	    provision for client choice and does not even allow the
	    client to find out the characteristics of the particular hybrid
	    implementation, chosen by the server.
	  </t></li>
	  <li><t>
	    The updating of ACLs in response to changes in the mode attribute
	    is another area in which previous specifications have chosen, for
	    reasons which remain unclear, to allow a wide range of server
	    behavior.
	  </t><t>
	    Only a single part of the necessary ACL change is clearly
	    specified as compliant with the spec.
	  </t><t>
	    On the other hand, use of this approach is discouraged using
	    non-normative terms
	  </t></li>
	</ul>
	<t>
	  The combination of all the above has created a difficult
	  interoperability situation. While it is often noted that
	  clients are working in this environment, without complaining
	  about the situation, we have to understand the reason why this
	  might be so:
	</t>
	<ul>
	  <li><t>
	    Unix clients have good reason to stay away from ACLs that
	    use features, such as extend-only ACLs, or ACLs whose set of
	    users with permission to modify ACLs is different from the
	    single owning user. This leaves them no
	    occasion to discover that the handling of these is not
	    clearly specified.
	  </t><t>
	    Some clients have ACL-related APIs (e.g. those appropriate
	    to UNIX ACLs) while for clients that have APIs oriented
	    to NFSv4 ACLs, any incompatibilities will be perceived by
	    the applications, leading to a situation in which problems
	    cannot be brought to the attention on the working group in
	    any context in which a reasonably prompt resolution can be
	    expected.
	  </t></li>
	  <li><t>
	    By discouraging direct client access to the ACLs, the need
	    for clear specification of ACL semantics were reduced. 
	  </t><t>
	    On the other hand, clients were given no corresponding way
	    to avoid clear specification of ACL semantics when deciding on
	    the ACL to effect a given pattern of authorization for a file.
	  </t></li>
	  <li><t>
	    No interoperability testing.
	  </t></li>
	  <li><t>
	    Low expectations in the ACL support area, which might be a
	    consequence of choices made and not made decades ago
	   </t></li>
	</ul>
	<t>
	  Given the importance of security, this unfortunate situation
	  cannot be allowed to persist indefinitely even if it might not
	  be possible to fully resolve without the sort of protocol extensions
	  that cannot be done in a document such as this. However, we can
	  make a set of changes such as the following in this document
	  to describe clearly designate optional server behavior and
	  leave it to later documents to provide the necessary extensions
	  defining ways for the client to find out about or affect
	  server choices.
	</t>
	<ul>
	  <li><t>
	    Eliminate the suggestions that the fact that servers behave
	    in a particular way necessarily implies that clients have to
	    accept this behavior 
	  </t></li>
	  <li><t>
	    Use "<bcp14>MAY</bcp14>" rather than "<bcp14>SHOULD</bcp14>" in
	    cases in which "<bcp14>SHOULD</bcp14>" is used without any
	    clear indications of valid reasons to ignore a recommendation.
	   </t></li>
	   <li><t>
	     Eliminate, to the degree possible, situation in which, multiple
	     behaviors are allowed, with no clear understanding why
	     allowing such freedom is needed.
	   </t></li>
	</ul>
      </section>
    </section>
  </section>
    <section anchor="REQL">
      <name>Requirements Language</name>
      <section anchor="REQL-def">
	<name>Keyword Definitions</name>
        <t>
	  The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
	  "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>",
	  "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>",
	  "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>",
	  "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>"
	  in this document are to be
	  interpreted as specified in BCP 14 <xref target="RFC2119"/>
	  <xref target="RFC8174"/> when, and only when,
	  they appear in all capitals, as shown here.
	</t>
      </section>

      <section anchor="REQL-special">
        <name>Special Considerations</name>
        <t>
          Because this document needs to revise previous treatments of
	  its subject, it will need to cite previous treatments of issues
	  that now need to be dealt with in a different way.  This will
	  take the form of quotations from documents whose treatment
	  of the subject is being obsoleted, most often as direct
	  quotation but
	  sometimes as indirect ones as well.
	</t>
	<t>
	  Paragraphs headed "[Previous
	  Treatment] or otherwise annotated as having that status,
	  as described in <xref target="OVIEW"/>, can be considered
	  quotations in this context.
	</t>
	<t>
          Such treatments in quotations will involve use of these
	  BCP14-defined terms in two noteworthy ways:
	</t>
	<ul>
	  <li><t>
	    The term may have been used inappropriately (i.e not in accord
	    with <xref target="RFC2119"/>), as has been the case
	    for the "<bcp14>RECOMMENDED</bcp14>" attributes, which are in
	    fact <bcp14>OPTIONAL</bcp14>.
	  </t><t>
	    In such cases, the surrounding text will make clear that the
	    quoted text does not have a normative effect.
	  </t><t>
	    Some specific issues relating to this case are
	    described below in <xref target="AUTHFA-attr"/>.  
	  </t></li>
	  <li><t>
	    The term may been used in accord with
	    <xref target="RFC2119"/>,
	    although the resulting normative statement is now felt to be
	    inappropriate.
	  </t><t>
	    In such cases, the surrounding text will need to make clear
	    that the text quoted is no longer to be considered normative,
	    often by providing new text that conflicts with the quoted,
	    previously normative, text.
	  </t><t>
            An important instance of this situation is the description of
	    AUTH_SYS as an "<bcp14>OPTIONAL</bcp14>" means of authentication".
	    For detailed discussion of this case, see Sections
	    <xref target="IDENT" format="counter"/> and
	    <xref target="SECCON-changes-authsys" format="counter"/>
	  </t></li>
	</ul>
    </section>
  </section>
  <section anchor="UINTRO">
    <name>Introduction to this Update</name>
    <t>
      There are a number of noteworthy aspects to the updated approach
      to NFSv4
      security presented in this document:
    </t>
    <ul>
      <li><t>
	There is a major rework of the security framework to take advantage
	of work done in <xref target="RFC9289"/>, as described in
	<xref target="OVIEW-motive"/>.
      </t><t>
	NFSv4 security is still built on RPC, as had been done previously.
	However, it is now able to take advantage of security-related
	facilities provided on a per-connection basis.
	For more information about this transformation, see
	<xref target="UINTRO-conn"/>.
      </t><t>
        For an overview of changes made so far as part of this rework,
        see <xref target="CHG-motive"/>.
      </t></li>
      <li><t>
	This document deals with all minor versions together, although there
	is a need for exceptions to deal with, for example, pNFS security.
      </t><t>
        For more detail about how minor version differences will be
        addressed, see
        Sections <xref target="UINTRO-mult" format="counter"/> and
	<xref target="UINTRO-feat" format="counter"/>.
      </t></li>
      <li><t>
	There is a new Security Considerations section including a
	threat analysis.
      </t></li>
      <li><t>
	There has been extensive work to clarify the multiple types of
	authorization within NFSv4 and deal more completely with the
	co-ordination of ACL-based and mode-based file access authorization.
	this work is discussed in <xref target="UINTRO-needwork"/>
      </t></li>
    </ul>
      <section anchor="UINTRO-conn">
	<name>Per-connection Security Features</name>
	<t>
	  There are a number of security-related facilities that can be
	  provided on a per-connection basis, eliminating the need to
	  provide such support on a per-request basis, based on the
	  RPC auth-flavor used.  
	</t>
	<t>
	  These will initially be provided, in most cases,
	  by RPC-with-TLS but similar
	  facilities might be provided by new versions of existing
	  transports or new RPC transports.
	</t>
	<ul>
	  <li><t>
	    The transport or a layer above it might provide encryption of
	    requests and replies,
	    eliminating the need for privacy and integrity services to be
	    negotiated later and applied
	    on a per-request basis.
	  </t><t>
	    While clients might choose to establish connections that provide
	    such
	    encryption, servers can establish policies allowing access to
	    certain pieces of the namespace using such security facilities, or
	    limiting access to those providing privacy, allowing the use
	    of either per-connection encryption or privacy services
	    provided by RPCSEC_GSS.  
          </t></li>
	  <li><t>
	    The transport or a layer above it might provide mutual
	    authentication of the client
	    and server peers as part of the establishment of the connection
	    This authentication is distinct from the the mutual
	    authentication
	    of the client user and server peer, implemented within the
	    RPCSEC_GSS framework.
	  </t><t>
	    This form of authentication is of particular importance when 
	    the server allows the use of the auth-flavors AUTH_SYS and
	    AUTH_NONE, which have no provision for the authentication of the
	    user requesting the operation.
	  </t><t>
	    While clients might choose, on their own,to establish
	    connections without such
	    peer authentication, servers can establish policies a limiting
	    access to certain pieces of the namespace without such peer
	    authentication or only allowing it when using RPCSEC_GSS.  
          </t></li>
	</ul>
	<t>
	  To enable server policies to be effectively communicated to
	  clients, the security negotiation framework now allows
	  connection characteristics to be specified using pseudo-flavors
	  returned as part of the response to SECINFO and SECINFO_NONAME.
	  See <xref target="NEGO"/> for details.
	</t>
      </section>
      <section anchor="UINTRO-mult">
	<name>Handling of Multiple Minor Versions</name>
	<t>
	  In some cases, there are differences between minor versions in
	  that there are security-related features, not present in all
	  minor versions.
	</t>
	<t>
	  To deal with this issue, this document will focus on a few
	  major areas listed below which are common to all minor versions.
	</t>
	<ul>
	  <li><t>
	    File access authorization (discussed in <xref target="AUTHFA"/>)
	    is the same in all minor versions together with the
	    identification/
	    authentication infrastructure supporting it (discussed in
	    <xref target="IDENT"/>) provided by RPC and applying to all
	    of NFS.
	  </t><t>
	    An exception is made regarding labelled NFS, an optional
	    feature within NFSv4.2, described in 
	    <xref target="RFC7862"/>.
	    This is discussed as a version-specific feature in this
	    document in <xref target="AUTHL"/>.
	  </t></li>
	  <li><t>
	    Features to secure data in-flight, all provided by RPC,
	    together with the negotiation infrastructure to support
	    them are common to all NFSv4 minor versions, are discussed in
	    <xref target="NEGO"/>.
	  </t><t>
	    However, the use of SECINFO_NONAME, together with changes
	    needed for connection-based encryption, paralleling those
	    proposed here for SECINFO, is treated as a version-specific
	    feature and, while mentioned here, will be fully documented
	    in new NFSv4.1 specification documents.
	  </t></li>
	  <li><t>
	    The protection of state data from unauthorized modification
	    is discussed in <xref target="AUTHST"/>)
	    is the same in all minor versions together with the
	    identification/
	    authentication infrastructure supporting it (discussed in
	    <xref target="IDENT"/> by security services such as
	    those provided by RPC-with-TLS.
	  </t><t>
	    It needs to be noted that state protection based on RPCSEC_GSS
	    is treated as a version-specific feature and will continue to be
	    described by <xref target="RFC8881"/> or its successors.
	    Also,
	    it needs to be noted that the use of state protection was not
	    discussed in <xref target="RFC7530"/>.
	  </t></li>
	</ul>
      </section>
      <section anchor="UINTRO-feat">
	<name>Handling of Minor-version-specific features</name>
	<t>
	  There are a number of areas in which security features differ among
	  minor versions, as discussed below.  In some cases, a new
	  feature requires specific security support while in others
	  one version will have a new feature related to enhancing the
	  security infrastructure.
	</t>
	<t>
	  How such features are dealt with in this document depends on
	  the specific feature.
	</t>
	<ul>
	  <li><t>
            In addition to SECINFO, whose enhanced description appears in
	    this document, NFSv4.1 added a new SECINFO_NONAME operation,
	    useful for pNFS file as well as having some non-pNFS uses.
	  </t><t>
            While the enhanced description of SECINFO mentions SECINFO_NONAME,
	    this is handled as one of a number of cases in which the
	    description has to indicate that different actions need to be
	    taken for different minor versions.
	  </t><t>
            The definitive description of SECINFO_NONAME, now appearing in
	    <xref target="RFC8881"/> needs to be modified to match
	    the description of SECINFO
	    appearing in this document.  It is expected that this will be
	    done as part of the rfc5661bis process.
	  </t><t>
	    The security implications of the security negotiation
	    facilities as a whole will be addressed in the security
	    considerations section of this document. 
          </t></li>
	  <li><t>
            The OPTIONAL pNFS feature added in NFSv4.1 has its own
	    security needs which parallel closely those of non-pNFS
	    access but are distinct, especially when the storage access
	    protocol used are not RPC protocols. As a result,
	    these needs and the means to satisfy
	    them are not discussed in this document.
	  </t><t>
            The definitive description of pNFS security will remain in
	    <xref target="RFC8881"/>
	    and its successors (i.e. the eventual rfc5661bis document).
	    However,
	    because pNFS security relies heavily on the infrastructure
	    discussed here, it is anticipated that the new treatment of
	    pNFS security will deal with many matters by referencing
	    the overall NFS security
	    document.
	  </t><t>
            The security considerations section of rfc5661bis will deal with
	    pNFS security issues.
          </t></li>
	  <li><t>
            In addition to the state protection facilities described
	    in this document, NFS has another set of such facilities that
	    are only implemented in NFSv4.1.
	  </t><t>
	    While this document will discuss the security implications of
	    protection against state modification, it will not discuss the
	    details of the NFSv4.1-specific features to accomplish it.
	  </t></li>
	  <li><t>
	    The additional NFSv4.1 acl attributes, sacl and dacl, are discussed
	    in this document, together with the ACL inheritance features
	    they enable.  
	  </t><t>
	    As a result, the responsibility for the definitive description
	    of these attributes will move to overall NFS security document,
	    with the fact that they are not available in NFSv4.0 duly noted.
	    While these attributes will continue to be mentioned in
	    NFSv4.1 specification documents, the detailed description
	    appearing in <xref target="RFC8881"/> will be removed
	    in successor documents.
          </t></li>
	  <li><t>
	    Both NFSv4.0 and NFSv4.1 specifications discussed the
	    coordination of the values the mode and ACL-related attributes.
	    While the treatment in <xref target="RFC8881"/> is more
	    detailed, the differences
	    in the approaches are quite minor.
	  </t><t>
	    [Consensus Item #25a]:
	    This document will provide a unified treatment of these issues,
	    which will note any differences of treatment that
	    apply to NFSv4.0.  Changes applying to NFSv4.2 will also be noted.
	  </t><t>
	    As a result, this document will override the treatment within
	    <xref target="RFC7530"/> and 
	    <xref target="RFC8881"/>. This material will be removed in the
	    rfc5661bis
	    document suite and replaced by a reference to the treatment in
	    the NFSv4 security RFC.
          </t></li>
	  <li><t>
	    The protocol extension defined in <xref target="RFC8257"/>,
	    now part of NFSv4.2, is also related to the issue of
	    co-ordination of acl and mode attributes and will be discussed
	    in that context.
	  </t><t>
	    Nevertheless, the description in <xref target="RFC8257"/>
	    will remain definitive.
          </t></li>
	  <li><t>
	    The NFSv4.1 attribute set-mode-masked attribute is mentioned
	    together with the
	    other attributes implementing the POSIX authorization model.
	  </t><t>
	    Because this attribute. while related to security, does not
	    substantively modify the security properties of the protocol,
	    the full description of this attribute, will continue to be
	    the province of the NFSv4.1 specification proper.
          </t></li>
	  <li><t>
	    There is a brief description of the v4.2 Labelled NFS feature
	    in <xref target="AUTHL"/>.   Part of that description
	    discusses the limitations in the description of that feature
	    within <xref target="RFC7862"/>.
	  </t><t>
	    Because of some limitations in the description, it is not
	    possible to provide an appropriate security considerations
	    section for that feature in this document.
	  </t><t>
	    As a result, the responsibility for providing an appropriate
	    Security Considerations section remains, unrealized for now,
	    with the NFSv4.2 specification document and its possible
	    successors.
          </t></li>
	</ul>
      </section>
      <section anchor="UINTRO-needwork">
        <name>Features Needing Extensive Clarification</name>
        <t>
	  For a number of authorization-related features, the existing
	  descriptions
	  are inadequate for various reasons:
        </t>
	<ul>
	  <li><t>
	    In the description of the use of the mode attribute
	    in implementing the POSIX-based authorization model,
	    critical pieces of the semantics are not mentioned, while,
	    ironically, the corresponding semantics for ACL-based
	    authorization are discussed.
	  </t><t>
	    This includes the authorization of file deletion and of
	    modification of the mode, owner and owner-group attributes.
	    For ACL-based authorization, there is an attempt to
	    provide the corresponding description.
	  </t></li>
	  <li><t>
	    The description of authorization for ACLs is more complete
	    but it needs further work, because the previous specifications
	    make extensive efforts, in my view misguided, to allow an
	    enormous range of server behaviors, making it hard for a
	    client to know what the effect of many actions, and the
	    corresponding security-related consequences, might be. 
	  </t><t>
	    Troublesome in this connection were the discussion of ACE mask bits
	    which essentially treats every mask bit, as its own OPTIONAL
	    feature, the use of "<bcp14>SHOULD</bcp14>" and
	    "<bcp14>SHOULD NOT</bcp14>" in situations which it is
	    unclear what valid reasons to ignore the recommendation might be,
	    and cases in which it is is simply stated that some servers do some
	    particular thing, leaving the unfortunate implication that clients
	    need to be prepared for a vast range of server behaviors.
	  </t><t>
	    This approach essentially treated ACLs in a manner appropriate
	    to an experimental feature even though in appeaed in a
	    Proposed Standard.
	  </t></li>
	  <li><t>
	    Similar issues apply to descriptions related to the need
	    to co-ordinate the values
	    of the mode attribute and the ACL-related attributes.
	  </t><t>
	    Although the need for such coordination is recognized.  There
	    are multiple modes of mapping an ACL  to a
	    corresponding mode together with multiple sources of
	    uncertainty about the reverse mapping.
	  </t><t>
	    In addition, certain of the mapping algorithms have flaws in that
	    their behavior under unusual circumstances providing results
	    that appear erroneous.
	  </t></li>
	</ul>
	<t>
	  Dealing with these issues is not straightforward, because
	  the appropriate resolution will depend on:
	</t>
	<ul>
	  <li><t>
	    The actual existence of server implementations with non-preferred
	    semantics.
	  </t><t>
	    In some cases in which "<bcp14>SHOULD</bcp14>" was used, there may
	    not have been any actual severs choosing to ignore the
	    recommendation, eliminating the possibility of compatibility
	    issues when changing the "<bcp14>SHOULD</bcp14>" to a formulation
	    that restricts the server's choices.
	  </t></li>
	  <li><t>
	    The difficulty of modifying server implementations to eliminate
	    or narrow the effect of non-standard semantics.
	  </t><t>
	    One aspect of that difficulty might be client or application
	    expectations based on existing server implementations, even if
	    the existing specifications give the client no assurance that
	    that server's behavior is mandated by the standard.
	  </t></li>
	  <li><t>
	    Whether the existing flaw in some existing recommended actions to
	    be performed by the server is sufficiently troublesome to justify
	    changing the specification at this point.
	  </t></li>
	</ul>
	<t>
	  This sort of information will be used in deciding whether to:
	</t>
	<ul>
	  <li><t>
            Narrow the scope of allowable server behavior to those actually
	    used by existing severs.
	  </t></li>
	  <li><t>
            Limiting the  negative effects of unmotivated
	    <bcp14>SHOULD</bcp14>s
	    by limiting valid reasons to ignore the recommendation to
	    the difficulty of changing existing implementations.
	  </t><t>
	    This would give significant guidance to future implementations,
	    while forcing clients to live with the uncertainty about existing
	    servers
	  </t></li>
	  <li><t>
	    Tie a more restricted set of semantics to nominally unrelated
	    OPTIONAL features such as implementation of dacl and sacl.
	  </t><t>
	    This would provide a way to allow the development of newer servers
	    to proceed on a firmer basis, without requiring changes on
	    older servers that do not support these SMB-oriented attributes.
	  </t></li>
	  <li><t>
	    Provide means that clients could use to determine,
	    experimentally,
	    what semantics
	    are provided by the server.
	  </t><t>
	    Would need to be supported by a requirement/assurance that
	    a server behave uniformly, at least within the scope of a
	    single file system.
	  </t></li>
	  <li><t>
	    Allow the provision of other ways for the client to know the
	    semantics choices made by the server or the file system.
	  </t><t>
	  </t></li>
	</ul>
	<t>
	  Despite the difficulty of addressing these issues, if the
	  protocol is to be secure and ACLs are to be widely available,
	  these problems have to be addressed.   While there has not been
	  significant effort to provide client-side ACL APIs and there
	  might not be for a while, we cannot have a situation in which the
	  security specification makes that development essentially impossible.
	</t>
      </section>
      <section anchor="UINTRO-wip">
        <name>Process Going Forward</name>
	<t>
	  Because of the scope of this document, and the fact that it
	  is necessary to modify previous treatments of the subject
	  previously published as Proposed Standards, it is necessary
	  that the process of
	  determining whether there is Working Group Consensus to submit
	  it for publication be more structured than that used for
	  the antecedent documents.
	</t>
	<t>
	  In order to facilitate this process, the necessary changes which
	  need to be made, beyond those clearly editorial in nature, are listed
	  in <xref target="ISSUES"/>.  As working group review and discussion
	  of this document and its successors proceeds, there will be occasion
	  to
	  discuss each of these changes, identified by the annotations
	  described in <xref target="OVIEW-notation"/>.
	</t>  
	<t>
	  Based on working group discussions, successive document versions
	  will do one of the following for some set of consensus items:
	</t>
	<ul>
	  <li><t>
	    Deciding that the replacement text is now part of a new
	    working group consensus.
	  </t><t>
	    When this happens, future drafts of the document will be
	    modified to remove the previous treatment, treat the proposed
	    text as adopted, and remove Author Asides or replace them
	    by new text explaining why a new treatment of the matter has been
	    adopted or pointing the reader to an explanation in
	    <xref target="CHG"/>.
	  </t><t>
	    At this point, the consensus item will be removed from
	    <xref target="ISSUES"/> and an explanation for the change
	    will be added to <xref target="CHG"/>.
	  </t></li>
	  <li><t>
	    Deciding that the general approach to the issue, if not
	    necessarily the specific current text has reached the point
	    of "general acceptance" as defined in <xref target="ISSUES"/>
	  </t><t>
	    In this case, to facilitate discussion of remaining issues, the
	    text of the document proper will remain as it is.
	  </t><t>
	    At this point, the consensus item will be marked within the 
	    table in <xref target="ISSUES"/> as having reached general
	    acceptance, indicating the need to prioritize discussion in
	    the next document cycle, aimed at arriving at final text to
	    address the issue.
	  </t><t>
	    In addition,  an explanation for the change
	    will be added to <xref target="CHG"/>.
	  </t></li>
	  <li><t>
	    Deciding that modification of the existing text is necessary to
	    facilitate eventual consensus, based on the working group's
	    input.
	  </t><t>
	    In this case, there will be changes to the document proper in
	    the next draft revision.  In some cases, because of the need for
	    a coherent description, text outside the consensus item may be
	    affected.  
	  </t><t>
	    The table in <xref target="ISSUES"/> will be updated to
	    reflect the new item status while <xref target="CHG"/> is
	    not expected to change.
	  </t></li>
	  <li><t>
	    Deciding that the item is best dropped in the next draft.
	  </t><t>
	    In this case, the changes to the document proper will be the
	    inverse of those when a change is accepted by consensus.  The
	    previous treatment will be restored as the current text while
	    the proposed new text will vanish from the document at the next
	    draft revision.  The Author Aside will be the basis for an
	    explanation of the
	    consequences of not dealing with the issue.
	  </t><t>
	    At this point, the consensus item will be removed from
	    <xref target="ISSUES"/>.
	  </t></li>
	</ul>
	<t>
	  The changes that the working group will need to reach consensus
	  on, either to accept (as-is or with significant modifications) or
	  reject can be divided into three groups.
	</t>
	<ul>
	  <li><t>
	    A large set of changes, all addressing issues mentioned in
	    <xref target="OVIEW-motive"/>, were already present in the initial
	    I-D so that there has been the opportunity for working group
	    discussion of them, although that discussion has been quite
	    limited so far.
	  </t><t>
	    As a result, a small set of these changes is marked, in
	    <xref target="ISSUES"/>, as having reached general acceptance.
	  </t><t>
	    That subset of these changes changes, together with the
	    organizational changes to
	    support them are described in <xref target="CHG-motive"/>.
	  </t></li>
	  <li><t>
	    Another large set of changes were made in draft -02.
	    These mostly concern the issues mentioned in
	    <xref target="UINTRO-needwork"/> None of these changes is
	    yet considered to have reached general acceptance.
	  </t><t>
	    The issues that need to be addressed are described in
	    <xref target="CHG-nclar"/> while the possible approaches
	    that might be taken to resolve these issues are described
	    in <xref target="CHG-clarfix"/>.
	  </t></li>
	  <li><t>
	    There remain a set of potential changes for which a need
	    is expected but for which no text is yet available.
	  </t><t>
	    Such changes have associated Author Asides and are listed in
	    <xref target="ISSUES"/>.
	  </t><t>
	    The text for these changes is expected to be made available
	    in future document revisions and they will be processed then,
	    in the same way as other changes will be processed now.
	  </t><t>
	    If and when such changes reach general acceptance, they will
	    be explained in the appropriate subsection of <xref target="CHG"/>.
	  </t></li>
	</ul>
      </section>
  </section>

  <section anchor="INTRO">
    <name>Introduction to NFSv4 Security</name>
    <t>
      Because the basic approach to security issues is so similar for all
      minor versions, this document applies to all NFSv4 minor versions. The
      details of the transition to an NFSv4-wide document
      are discussed in Sections <xref target="UINTRO-mult" format="counter"/>
      and <xref target="UINTRO-feat" format="counter"/>.
    </t>
    <t>
      NFSv4 security is built on facilities provided by the RPC layer,
      including various auth-flavors and other security-related
      services provided by RPC.
    </t>
    <t>
      Support for multiple auth flavors can be provided.
      Not all of these actually
      provide authentication, as discussed in <xref target="IDENT"/>.
    </t> 
    <ul>
      <li><t>
	Support for RPCSEC_GSS is <bcp14>REQUIRED</bcp14>, although
	use of other auth-flavors is provided for.
      </t><t>
        This auth-flavor provides for mutual authentication of the principal
        making the request and the server performing it.
	</t><t>
	This auth-flavor allows the client to request the provision of
	encryption-based services to provide privacy or integrity
	for specific requests.  Although such services are often provided,
        on a per-connectio basis, by RPC, this support is useful, when
	such services are not supported or are otherwise
	unavailable.
      </t></li>
      <li><t>
	AUTH_SYS, provides identification of the principal making the
	request but <bcp14>SHOULD NOT</bcp14> be used unless the
	client peer sending the request can be authenticated and there
	is protection against the modification of the request in flight.
      </t><t>
        Both of the above require specific RPC support such as that
        provided by RPC-with-TLS <xref target="RFC9289"/>.
      </t></li>
      <li><t>
	AUTH_NONE does not provide identification of the principal making
	the request so would only be used for requests for which there
	is no such principal or for which it would irrelevant.
      </t><t>
        The restrictions mentioned above for AUTH_SYS apply to AUTH_NONE
        as well.
      </t></li>
    </ul>
    <t>
      There are important services that can be provided by RPC, 
      when RPC-with-TLS or similar transport-level
      facilities are available. 
    </t>
    <ul>
      <li><t>
	Such services can provide data security to all requests on the
	connection.
	This is to be preferred to data security provided by the RPC auth
	flavor because it provides protection to the request headers, because
	it applies to requests using all authentication flavors, and because
	it is more likely to be offloadable.
      </t></li>
      <li><t>
	These services can authenticate the server to the client peer.  This
	is desirable since that authentication applies even when AUTH_SYS or
	AUTH_NONE is used.
      </t></li>
      <li><t>
	The client-peer can be authenticated to the server at the
	time the connection is set up.  This is essential to allow
	AUTH_SYS to be used with a modicum of security, based on the
	server's level of trust with regard to the client peer.
      </t></li>
    </ul>
    <t>
      Because important security-related services depend on the security
      services, rather than the auth flavor, the process of
      security negotiation, described in <xref target="NEGO"/>, has been
      extended to provide for the negotiation of
      appropriate connection characteristics at connection time if
      the server's policy
      limits the range of transports being used and also when use of
      a particular auth flavor on a connection with inappropriate security
      characteristics causes
      NFS4ERR_WRONGSEC to be returned.
    </t>
    <t>
      The authentication provided by RPC, is used to provide the basis
      of authorization, which is discussed
      in general in <xref  target="AUTHG"/>. This includes file access
      authorization, discussed in Sections
      <xref target="AUTHFA" format="counter"/> through
      <xref target="AUTHCOMB" format="counter"/> and state modification
      authorization, discussed in <xref target="AUTHST"/>
      
    </t>
    <t>
      File access is controlled by the server support for and client use of
      certain recommended attributes, as described in
      <xref target="AUTHFA-attr"/>.  Multiple file access model are
      provided for and the considerations discussed in
      <xref target="AUTHCOMM"/> apply to all of them.
    </t>
    <ul>
      <li><t>
	The mode attribute provides a POSIX-based authorization model, as
	described in <xref target="AUTHFA-posix"/>
      </t></li>
      <li><t>
	The ACL-related attributes acl, sacl, and dacl (the last two
	introduced in NFSv4.1) support a finer grained authorization model
	and provide
	additional security-related services.  The structure of ACLs is
	described in new ACL document
	<xref target="I-D.dnoveck-nfsv4-acls"/>.  
      </t><t>
        The ACL-based authorization model is described in
        <xref target="AUTHFA-acl"/>	
      </t><t>
        The additional security-related services are described in
        <xref target="OTHACL"/>.  These also rely on the authentication
	provided by RPC.
      </t></li>
      <li><t>
	Because there are two different approaches  to file-access
	authorization, servers might implement both, in which case
	the associated attributes need to be coordinated as described
	in <xref target="AUTHCOMB"/>.
      </t></li>
      <li><t>
	NFSv4.2 provides a file access authorization model oriented toward
	Mandatory Access Control.  It is described in <xref target="AUTHL"/>.
	For reasons described there, its security properties are hard to
	analyze in detail and this document will not consider it as part
	of the NFSv4 threat analysis.
      </t></li>
    </ul>
    <t>
      Authorization of locking state modification is discussed in
      <xref target="AUTHST"/>.  This form of authorization relies
      on the authentication of the client peer as opposed to file
      access authorization, which relies on authentication of the
      client principal.
    </t>
    <section anchor="INTRO-term">
      <name>NFSv4 Security Terminology</name>
      <t>
	In this section, we will define the security-related terminology
	used in this document.   This is particularly important for
	NFSv4 because many of the terms terms related to security in
	previous specification may be hard to understand because their
	meanings have changed or have been used inconsistently, resulting
	in confusion. 
      </t>
      <t>
	The following terms are listed in alphabetical order:
      </t>
      <ul>
	<li><t>
	  "Access Control" denotes any control implemented by a server peer
	  to limit or regulate file system access  to file system objects.
	  It includes but is not limited to authorization decisions.  Access
	  control features can be divided into those which are "Discretionary"
	  or "Mandatory" as described below.
	</t></li>
	<li><t>
	  "ACL" or "Access Control List" denotes a structure used, like
	  the mode (see below), to defines the privileges that individual
	  users have with respect to a given file.   These structures
	  provide more options than modes with regard to the association
	  of privileges with specific users or group and often
	  provide a finer-graned
	  privilege structure as well.  This specification will have need to
	  refer to two types of ACLs.
        </t><t>
	  The ACLs intended to be presented in the acl, sacl, and
	  dacl attributes are called
	  "NFSv4 ACLs".   This ACL format, was modeled on the the semantics
	  of the SMB ACL format which provide a privilege model substantially
	  finer-grained than that provided by POSIX modes.
        </t><t>
	  [Consensus needed (Item #56a)]:  
	  Another ACL type derives from an attempt to define, within
	  POSIX, a UNIX-oriented approach to ACLs which was published
	  as a draft (POSIX 1003.1e draft 17), but subsequently withdrawn.
	  Despite the withdrawal of this draft and the working group's
	  decision to adopt a native NFsv4 ACL format based on SMB ACLs,
	  this document
	  will have to discuss these ACLs, which we will term "UNIX ACLs"
	  because many server file systems do not support the finer-grained
	  privilege model needed by the the NFSv4 ACL model and because
	  many clients are built on systems whose only ACL-related API
	  is based on the UNIX ACL model.
	</t></li>
	<li><t>
	  "authentication" refers to a reliable determination that
	  one making a request is in fact who he purports to be.
	  Often this involves cryptographic means of demonstrating
	  identity.
        </t><t>
	  This is to be distinguished from "identification" which simply
	  provides a specified identity without any evidence to verify
	  that the identification is accurate.
	</t><t>
	  In the past, these terms have been confused, most likely because
	  of confusion engendered by th use of the term "authentication flavor"
	  including flavors for which only identification is provided
	  or which do not provide even identification.
	</t></li>
	<li><t>
	  "authorization" refers to the process of determining whether
	  a request is authorized, depending on the resources (e.g. files)
	  to be accessed, the identity of the entity on whose behalf the
	  request was issued,
	  and the particular action to be performed.
        </t><t>
	  Depending on the type of request, the entity whose identity
	  is referenced can be a user, a peer, or a combination of
	  both.
        </t><t>
	  Authorization is distinct from authentication.  However, performing
	  authorization based on identities which have not been authenticated
	  makes secure operation impossible since use of unauthenticated
	  identities allows acceptance of requests that are not properly 
	  authorized if the sender has the ability, as it typically does,
	  to pretend to be an authorized user/peer.
	</t></li>
	<li><t>
	  "client" refers to the entity responsible for setting up a
	  connection.  In most cases the client and the requester reside
	  on the same node but this not always the case for NFSv4 because of
	  the possibility of callback requests in which the server makes
	  some request of the client.
	</t></li>
	<li><t>
	  "confidentiality" refers to the assurance provided, typically
	  through encryption, that the contents of requests and responses
	  are not inadvertently disclosed to unauthorized parties.
	</t></li>
	<li><t>
	  "Discretionary Access Control" denotes forms of access control,
	  that rely on a user, such as the owner, specifying the privileges
	  that various users are to have.
	</t></li>
	<li><t>
	  "Mandatory Access Control" denotes forms of access control that
	  reflect choices made by the server peer and based on its policy
	  and that are typically based on the identity of the client peer
	  rather than the specific user making a request.   While such access
	  control is discussed in this document, it is important to note
	  that many forms of mandatory access control are discussed by
	  other NFsv4 documents and that there are forms that are not standardized.
	</t></li>
	<li><t>
	  [Consensus Needed, Entire Bulleted Item (Items #21a, #57a)]:
	  "Mode" designates a set of twelve flag bits used by POSIX-based
	  systems to control access to the file with which it is
	  associated.  In NFSv4, there are represented by the
	  <bcp14>REQUIRED</bcp14> attribute Mode.
        </t><t>
	  The three high-order flags are generally accessed only by
	  the client while low-order bits are divided into three three-bit
	  fields, which give, in order of decreasing numeric value,
	  the privileges to be associated with, the owner of the file, other
	  users in the group owning the file, and users not in the above
	  two categories.
        </t><t>
	  In most cases, the privileges associated with each successive
	  group are no greater than those for the previous group.  Modes
	  whose privileges are of this form are referred to as
	  "forward-slope modes" because the privilege level proceeds
	  downward as successive groups of users are specified.  Cases
	  in which the contrary possibility is realized are referred
	  to as "reverse-slope modes".
	</t></li>
	<li><t>
	  "peer" refer to the entity which is charged with requesting
	  or performing a specified
	  request as opposed to the entity on whose behalf the request is
	  requested or performed,
	  the principal;
	</t></li>
	<li><t>
	  "principal" refers to the specific entity (e.g. user) on whose
	  behalf a request is being made.
	</t></li>
	<li><t>
	  "privacy",  has in the past been used to refer, to what is now
	  referred to as "confidentiality".
	</t><t>
	  over time, this usage has changed so that the word most often
	  refers to applicability of data to a single individual and
	  person's right to prevent its unauthorized disclosure
	</t><t>
	  As a result, many  references to "privacy" in previous are no
	  longer appropriate and really refer to confidentiality.
	</t><t>
	  The NFSv4 protocol has no way to determine whether particular
	  data items raise privacy concerns (In the new sense).  NFSv4
	  provides confidentiality whatever type of data is being accessed
	  so that private data is kept private.
	</t></li>
	<li><t>
	  "integrity" refers to the assurance that data in a request has
	  not been modified in the process of transmission.   Such an
	  assurance is generally provided b means of a cryptographic
	  hash of the requests or response.
	</t></li>
	<li><t>
	  "requester" is the entity making a request, whether that entity
	  is on the client-side, as it most often is (forward-direction
	  request) or the server side, in th case of callback (reverse-direction
	  requests)
	</t></li>
	<li><t>
	  "responder" is the entity performing a request, whether that entity
	  is on the server side, as it most often is (forward-direction
	  request) or the client side, in the case of callbacks
	  (reverse-direction requests.
	</t></li>
	<li><t>
	  "server" refers to the entity to which the client connects.
	  In most cases the client and the responder reside
	  on the same node but this not always the case for NFSv4 because of
	  the possibility of callback requests in which the server makes
	  some request of the client.
	</t></li>
      </ul>
    </section>
    <section anchor="INTRO-scope">
      <name>NFSv4 Security Scope Limitations</name>
      <t>
	This document describes the security features of the NFSv4
	protocol and is unable to address security threats that are
	inherently outside the control of the protocol implementors.
	Such matters as out of this document's scope.
      </t>
      <t>
	As a way of clarifying the threats that this document, and the threat
	analysis in <xref target="SECTHREAT"/> can and cannot deal with,
	we list below the potential threats discussed Section 3.1 of
	<xref target="nist-209"/> and review how, if at all, it is
	discussed in the current document.  In cases in which the threat
	is dealt with in this document, distinctions are to be made between
	cases in which the issues have been dealt with directly or have been
	delegated to a lower layer on which the protocol is built and whether
	the issue has been addressed
	by the changes to NFSv4 security made by this document.
      </t>
      <ul>
	<li><t>
	  Regarding the possibility of "Credential Theft or Compromise",
	  this is not a matter that the NFSv4 protocols concern themselves
	  with or can address directly, despite its importance for security.
	  Depending on the auth flavor chosen, either the client
	  (for AUTH_SYS)
	  or a third-party (for RPCSEC_GSS), usually Kerberos, will be
	  responsible for credential verification.
	</t><t>
	  Since experience has shown that credential compromise
	  (e.g. through "phishing" attacks) is a
	  common occurrence, this problem cannot be ignored, even though 
	  NFSv4's reliance on RPC facilities for authentication might
	  be thought to make it out-of-scope as it would be RPC if had an
	  effective solution to the issue.   However, the urgency
	  of the situation this issue is such that will be discussed in
	  <xref  target= "SECTHREAT-creds"/>, even though no definitive solutions
	  to this issue are likely before this document is completed
	  and published.
	</t><t>
	  Regardless of such issues, the likelihood of such compromise 
	  has had a role in decisions made regarding the
	  acceptance and use of "superuser" credentials.  The possibility
	  of such compromise is also relevant
	  to implementation of means to synchronize credentials when they
	  are managed by the client, as described in
	  <xref target="SECTHREAT-auth-sys"/>
	</t></li>
	<li><t>
	  Regarding the possibility of "Cracking Encryption", prevention
	  of this is responsibility of the NFSv4 protocols but it is one
	  which has been delegated to RPC, so that its discussion in
	  Security Considerations will rely on RPCSEC_GSS and RPC-with-TLS
	  impelentations to manage the selectio and replacement of kets
	  for encryption so as to limit the possibility of such
	  unwanted encryption key discovery.
	</t></li>
	<li><t>
	  Regarding the possibility of "Infection of Malware and Ransomware",
	  NFSv4 has no direct role in preventing such infection, but does have
	  an important role in limiting its consequences, by limiting the
	  the ability of Malware to access or modify data, through the
	  file access authorization model supported by NFSv4 to limit access
	  to authorized users.  Of course, malware will be able to execute on
	  behalf of the user mistakenly invoking it but the authorization
	  model will server to limit the potential damage.
	</t><t>
	  The possibility of vertical privilege escalation is of concern
	  as regard the possible elevation to "superuser" privileges.  For
	  this reason, this document recommends that any such escalation
	  not be effective on the server, even if it happens on local
	  clients for which NFSv4 has no role.
        </t><t>
	  Execution of a ransomeware-based attack requires the attacker to
	  have the ability to read existing data and replacing it with an
	  encrypted version together with the ability to temporarily hide
	  the encryption from ongoing operations by intercepting requests
	  to read encrypted data and substitute the unencrypted data.
	</t></li>
	<li><t>
	  Regarding the possibility of
	  "Backdoors and Unpatched Vulnerabilities", it needs to be noted
	  that the NFSv4 protocols do not specify any backdoors even though
	  it is possible that might choose to provide such backdoors.  Since
	  it is not practical to specifically prohibit the existence of
	  such backdoors nor would they be enforceable if written, this
	  document will not attempt to do so.  Instead,
	  <xref target="SECCON-scope-insecure"/> will note the possibility
	  of such backdoors and
	  recommend against any such implementation, and include
	  implementations containing backdoors in the category of insecure
	  use that will not be dealt with in <xref target="SECTHREAT"/>.
        </t><t>
	  Although it is expected that vulnerabilities will be due to
	  incorrect implementations and thus outside the scope of this
	  document, the possibility of a protocol design errors cannot
	  be excluded.  In dealing with such eventualities, it is likely
	  that complete remediation would require co-ordinated changes on
	  the client and server 
	
	</t></li>
	<li><t>
	  Regarding the possibility of "Privilege Escalation", NFSv4 has
	  dealt with the possibility of vertical escalation by not allowing a
	  client-local escalation to superuser privileges to be effective
	  on the server.
        </t><t>
	  With regard to horizontal "escalation", NFSv4 provides for
   	  the use of various means RPC authentication of principals but
	  relies on the client operating system to make sure that one
	  user principal cannot masquerade as another.
	</t></li>
	<li><t>
	  Regarding the possibility of
	  "Human Error and Deliberate Misconfiguration", the approach taken
	  is to limit the need for the server to make complicated decisions
	  regarding the security requirements of each section of its namespace,
	  with many opportunities for misconfiguration, if the chosen security
	  requirements are insufficiently restrictive.   This is in
	  contrast to previous specifications which made such configuration
	  the centerpiece of the security approach.
	</t><t>
          Although it is possible to create configurations where certain
	  data, generally publicly accessible, are to be  made available without
	  encryption, this is expected to be a rarely used option with
	  the possibility of in-transit modification kept in mind
	  before adopting such use.
	</t></li>
	<li><t>
	  Regarding the possibility of "Physical Theft of Storage Media",
	  this a matter which, while of concern to those deploying NFSv4
	  server, will be considered out-of-scope since there is nothing
	  that the protocol could do to deal with this threat.
	  
	</t></li>
	<li><t>
	  Regarding the possibility of "Network Eavesdropping", when the
	  protocol implementation follows the recommendations in this
	  document, the
	  protocol's use of RPC facilities is designed, through the consistent
	  use of encryption to make it difficult for an attacker to
	  have access to the data being transmitted, to modify it, or
	  inject requests into an existing data stream.
	</t><t>
          The possibility of an attacker with access to the network
	  creating a new connection is best considered as a case of the
	  attacker pretending to be a client and is addressed in
	  <xref target="SECTHREAT-rogue-client"/>.
	</t></li>
	<li><t>
	  Regarding the possibility of "Insecure Images, Software and Firmware",
	  while attention to such matters is important for those deploying
	  NFSv4, it is important to note that these are matters outside the
	  control the NFSv4, which has to assume that the infrastructure it
	  is built is working properly.  As a result, this document will not
	  deal with the possibility of such threats.
	</t></li>
      </ul>
    </section>
  </section>

  <section anchor="ATTR">
    <name>Authorization-related Attributes</name>
    <t>
      NFSv4 operations are authorized (or not) based on the
      entity requesting the operation and the values of the
      authorization-related attributes documented in this section.
      The table in <xref target="ATTR-table"/> lists all such attributes
      with the actual
      descirptions appearing in three subsections based on the specfic
      authorization models supported by various NFSv4 protocols.
    </t>
    <ul>
      <li><t>
	There are a number of attributes derived from file characteristics
	defined by POSIX.  They are similar to the corresponding
	NFSv3 attributes, although they are different in form.
	These are described in <xref target="ATTR-posix"/>.
      </t></li>
      <li><t>
	In order to provide finer-grained control of authorization
	decisions, a number of acl-related attibutes are defined.
	These are described in <xref target="ATTR-aclr"/>.
      </t><t>
        [Consensus Required (Item #57b)]:	
        Although it might have been intended that the acl-related and
        POSIX-derived attributes would serve as two alternate modes
	authorization, with each <bcp14>OPTIONAL</bcp14>, that has
	not been possible, with the POSIX-derived model becoming
	<bcp14>REQUIRED</bcp14> while the acl-related one remains
        <bcp14>OPTIONAL</bcp14>.	
      </t><t>
        As the acl-related model has evolved, it was constrained to
        to work well with the POSIX-based model, as there were many
	clients who required support for POSIX authorization semantics.
      </t></li>
      <li><t>
	In addition, an addional authoization model was made availabe
	in NFSv4.2.  It is described in <xref target="ATTR-mac"/>.
      </t><t>
        This provides a form of Mandatory Access Control in which
        authorization decisions derived from the identity of the client
	making the request rather than the identifty of the specfic
	user/principal.  When enabled, it serves as an additional
	authorization step in addition to that specified  by
	POSIX-related attributes or ACLs.
      </t></li>
    </ul>
    <t>
      The NFSv4 protocols have integrated a set authorization-related
      attributes within the extensible attribute model, introduced
      in <xref target="RFC7530"/>.   This extensibility has been the
      basis of the introduction of additional <bcp14>OPTIONAL</bcp14>
      attriutes provided for in <xref target="RFC8178"/>
    </t>
    <t>
      As a result, different sets of attributes are valid in different
      minor versions.  Although attribubes are described in the
      specfications
      for the minor version in which they are introduced, and, in some
      cases, in specifications for later minor versions, the description
      in this document is definitive and overrides any other such specfication.
      This includes the following attributes:
    </t>
    <ul>
      <li>
        The attributes owner, group, mode, aclsupport and acl were
        introduced in NFSv4.0 and are valid in all minor versions.
      </li>
      <li>
	The attribute mode_set_masked, dacl, and sacl were introduced
	in NFSv4.1 and are valid in all minor versions except minor version
	zero.
      </li>
      <li>
	The attribute sec_label was introduced in NFSv4.2 and is only
	valid in minor version two.
      </li>
    </ul>
    <t>
      [Consensus Needed, Including List (Items #57b, #58a)]:",
       Although previous specifications have treated all of these as
       <bcp14>OPTIONAL</bcp14>, sometimes using the incorrect designation
       "RECOMMENDED", it has to be understood that there important
       exceptions that need to be noted:
     </t>
     <ul>
       <li><t>
	 In the interest of providng better assurances of meaningful
	 interoperaability to compliant servers and clients, the
	 attributes described in <xref target="ATTR-posix"/> (i.e.
	 owner, group, mode) are to be considered <bcp14>REQUIRED</bcp14>.
       </t></li>
       <li><t>
	 While it is reasonable to say, as <xref target="RFC8881"/>
	 does, that <bcp14>OPTIONAL</bcp14> need to be
	 "understood well enough
	 to warrant support", it should be the case that this
	 understanding is documented sufficiently to enable clients
	 and servers to interoperate and new implementations of each to
	 be implemented. Unfortunately, that condition
	 is not currently met for some attribues which we need to
	 realize are under-specified, andthus essential experimental,
	 even though formally
	 <bcp14>OPTIONAL</bcp14>.  The
	 details are discussed in Sections
	 ACLSPEC(ATTR-acl),
	 ACLSPEC(ATTR-dacl), and
	 <xref target="ATTR-seclabel"/>).  The intention, not yet
	 fully realized, is that new features described in the ACL
	 document might, when adopted,
	 allow the Acl, Dacl and Sacl attributes to be
	 designated as
	 <bcp14>OPTIONAL</bcp14> in fact, i.e. not under-specified.
       </t><t>
         [Author Aside (Item #58a)]:	 
	 It could be that, as discussed elsewhere, that the inadequate
	 semantic description referred to in the paragraph above
	 is the result of a flawed approach to the description of the
	 features, rather than to the attempt to support two types
	 of ACLs within the same set of attributes.
       </t></li>
     </ul>
    <section anchor="ATTR-idstrings">
      <name>Format of Id Strings in Authorization-related Attributes</name>
      <t>
	Unlike the case in NFSv3, users and groups are represented
	in NFSv4 by
	UTF-8-encoded Unicode strings.  These strings include:
      </t>
      <ul>
	<li>
	  [Consensus needed (Item #57c)]:
	  The values of the <bcp14>REQUIRED</bcp14> attribute Owner, as
	  described in
	  <xref target="ATTR-owner"/>.
	</li>
	<li>
	  [Consensus needed (Item #57c)]:
	  The values of the <bcp14>REQUIRED</bcp14> attribute Owner_group,
	  as described in
	  <xref target="ATTR-ogroup"/>
	</li>
	<li>
	  Values within the "who" field within Access Control Entries
	  as described in
	  ACLSPEC(ACL-ace).  These entries appear in the Acl,
	  Dacl, and Sacl attributes.
	</li>
      </ul>
      <t>
	[Author Aside, Including List (Item #59a)]:  This section
	had to be extensively revised in order to be clearer and to
	allow more uses of string representations of numeric ids.
	The previous
	treatment, which is not reproduced here, can be found in
	Section 5.9 of <xref target="RFC8881"/>. In the author's
	opinion, major revisions were necessary because:
      </t>
      <ul>
	<li><t>
	  The existing treatment, by leaving the methods of mapping
	  between strings and local user ids unspecified, created an
	  interoperability issue.  Since providing this mapping in a
	  secure way is difficult, the gap is likely to be filled in an
	  a way vulnerable to attack.
	</t><t>
	  While the need for flexibility might make it impossible to
	  specify mapping fully, the requirements for agreement between
	  client and server needed to be specified more clearly and
	  avoided where this can be done without impeding protool
	  operation.
	</t></li>
	<li><t>
	  There is inadequate attention to the additional implementation
	  needs to support multiple domain values.
	</t><t>
          The difficulties inherent in supporting all possible domains
	  are obscured, with the very real security issues essentially
	  ignored.
	</t></li>
	<li><t>
	  The description of the domain value as "meant to be a DNS domain"
	  is not clear and makes it harder to focus on the real
	  difficulties involved in providing coherent secure means
	  of providing necessary mappings for multiple domains.
	</t></li>
	<li><t>
	  Some negarive characterizations of the use of numeric ids appear
	  to be unjustified, leading to their non-use in situations in
	  which artificially mapping to the name@domain format creates
	  difficult issus while providing no benefit.
	</t></li>
      </ul>
      <t>
	[Consensus Needed, Including Rest of Section (Items #52a, #59a)]:
      </t>
      <t>
	These identifiers are represented by strings 
	which have two possible formats:
      </t>
      <ul>
	<li><t>
	  Strings of the format "name@domain" can be used with a number
	  of important benefits.  They are to be preferred in situations
	  in which the mapping between names and the 32-bit numeric ids
	  preferred by typical file systems is securely provided by
	  means of the RPC auth flavor being used, as is the case when
	  Kerberos services are made available through the use of RPCSECGSS.
	</t><t>
	  Servers would be able support multiple clients each with users
	  from one or
	  more domains, without requiring construction of a single
	  list of users together with associated authentication info.
	</t><t>
	  The number of users would not be limited by existing
	  hard-to-extend
	  limits such as the POSIX/NFSv3 use of a 32-bit field to
	  represent a
	  user or group id.
	</t></li>
	<li><t>
	  The string can be the ASCII representation o the 32-bit user or
	  group id.
	</t><t>
	  This format is to preferred when the auth flavor AUTH_SYS
	  is being used and in other cases in which the translation
	  between user names and numeric ids is not available or
	  creates security vulnerabilities.
	</t></li>
      </ul>
      <t>
	These strings are assigned the xdr type utf8str_mixed because
	the name and domain portions are treated differently:
      </t>
      <ul>
	<li>
	  The name portion is a utf8 string that is matched in a case-
	  sensitive manner without any attempt to treat distinct
	  canonically equivalent strings as the same.
	</li>
	<li>
	  The handling of the domain portion, including recognition
	  of equivalent string as the same is specified by the server.
	  However, when multple domains are supported, case-insensitivity
	  of ASCII characters is mandated by DNS, as well as translations
	  to and from punycode-encoded forms.
	</li>
      </ul>
      <t>
      It is expected that the client and server file systen
      will have their own local representation of users and
      user groups that is used for local storage or presentation to
      the end user.  In addition, it is expected that when these
      attributes are transferred between the client and server and
      the format used is of the form name@domain,
      the local representation is translated to that orm
      </t>
      <t>
	Although this allows for a client and server that both
	use the name@domain format and
	do not use the same local representation the ability to
	translate to a common format, there will often be cases
      in which both client and sever use the same internal format.
      This often happens with servers that only support a single
      domain.  However, regrdless of whether these forms are,
      in fact, different, it is inecessary, when such translation
      is necessary, that client and server
      agree on the following:
      </t>
      <ul>
	<li>
	  The set of valid strings that can appear as the domain
	  portion of these identifiers.  This set must have at least a
	  single member but when this not the case, the set known
	  to each client must be a subset of the set recognized by the
	  server.
	</li>
	<li><t>
	  For each valid domain string passed by a client and accepted
	  by a server, the server and client must agree on a means by
	  which the user designated by each user and group name can be
	  mapped to  a user or group so that each interprets all
	  name@domain strings identically.
	</t><t>
	  The above applies whether the client and server use the same
	  internal name repreentation or not.
	</t></li>  
      </ul>
      <t>
	When this translation is used, security principals and the groups
	they belong to need to be
	integrated within this arrangement since these identities
	need to be presented to the server in a form compatible with
	this new format.  The specfics depend on the auth
	flavor providing the principal identfication:
      </t>
      <ul>
	<li><t>
	  When auth flavors based on RPCSEC_GSS are used, the prinipal
	  is generally identified in a form easily converted to the
	  name@domain fornat.  For example, with Kerberos, the kerberos
	  user name can provide the name ortion while kerberos realm
	  can serve as the domain portion.
	</t></li>
	<li><t>
	  When the AUTH_SYS auth flavor is used, principals are
	  identified by a 32-bit numeric identifier which can be
	  generally teated in the same manner as numeric id's used 
	  locally within the file system to arive at a name with
	  the domain being the one assigned that filesysten.
	</t><t>
	  The idenification of principals <bcp14>MAY</bcp14> be
	  subject to filtering to eliminate users with a high
	  level of privilege.
	</t><t>
	  In the case of servers with filesystems that support the use
	  of multiple domains, clients for which use of AUTH_SYS is
	  supported need to be assigned to a specific domain so that
	  the principal identfications received are properly dealt with.
	</t></li>
      </ul>
      <t>
      The translation used to interpret owner and group strings is
      not specified as part of the protocol.  This allows various
      solutions to be employed, as long as the requirement mentioned
      above are satisfied and additionl security vulnerabilities are not
      created.  For example, a local translation
      table may be consulted that maps a numeric identifier to the
      user@domain syntax.  A name service may also be used to
      accomplish the translation.  A server may provide a more
      general service, not limited by any particular translation
      (which would only translate a limited set of possible strings)
      by storing the owner and owner_group attributes in local
      storage without any translation or it may augment a
      translation method by storing the entire string for attributes
      for which no translation is available while using the local
      representation for those cases in which a translation is
      available.
        </t>
        <t>
	  [Author Aside:] The next sentence previously used the
	  word "<bcp14>SHOULD</bcp14>.  Since the author has been
	  unable to determine valid reasons to do otherwise and has
	  no reason believe that any exist, the
	  new text uses "<bcp14>MUST</bcp14>".  It is possible that
	  the original author might have been thinking of "nobody" for this
	  but that case needs to be addressed separately and will need
	  to be clearly distinguished from "nobody@domain".
	</t>
	<t>
      Servers that do not provide support for all possible values of
      the owner and owner_group attributes <bcp14>MUST</bcp14>
      return an error
      (NFS4ERR_BADOWNER) when a string is presented that has no
      translation, as the value to be set for a SETATTR of the
      owner, owner_group, or as the who value in an ACE within
      the acl, sacl, or dacl attributes.  When a server does
      accept an owner or owner_group value as valid on a SETATTR
      (and similarly for the owner and group strings in an ACL), it
      is promising to return that same string when a corresponding
      GETATTR is done.  Configuration changes (including
      changes from the mapping of the string to the local representation)
      and ill-constructed
      name translations (those that include aliasing) may make that
      promise impossible to honor.  Servers need to  make appropriate
      efforts to avoid a situation in which these attributes have
      their values changed when no real change to ownership has
      occurred.
        </t>
        <t>
      The "domain" portion of the owner string will often be a
      DNS domain name, for example, user@example.org.  Servers should
      accept as valid a set of users for at least one value of the domain
      portion.  A
      server may treat other domains as having no valid
      translations.  A more general service is provided when a
      server is capable of accepting users for multiple domains
      values but the following will need to be attended to:
	</t>
	<ul>
	  <li><t>
	    When use of AUTH_SYS is allowed, the translation of
	    numeric ids to the form name@domain becomes problematic.
	  </t><t>
	    The server will need to determine the domain value to
	    be used based on the identity of the client peer.
	  </t></li>
	  <li><t>
	    When numeric ids are used in the file system the handling
	    of those ids needs to be modified to support multiple
	    sets of users with one set for each of the various
	    domain values supported.
	  </t><t>
	    One option is to add a small (i.e. 8- or 16-bit) field
	    to represent the chosen domain value will leaving the 32-bit
	    id field as it is.
	  </t><t>
	    It is also possible to map individual 32-bit id spaces
	    into a single 32-bit id space.  However, this involves
	    eastablishing for each component id space a restricted
	    mange, so that the mapping can be done without
	    resulting in conflicting reverse mappings.
	  </t></li>
	</ul>
        <t>
	  In cases in which translation is being used and there is no
	  translation available to the
	  client or server, the attribute value will be constructed
	  without the "@".  The absence of the @ from the
	  user or group string  signifies that no translation
	  was available at the sender and that the receiver of the
	  attribute should not use that string as a basis for
	  translation into its own internal format.  When the string
	  consists of a numeric value with no leading zeroes it can be
	  interprested as represeting the corresponding 32-bit numeric
	  id.  Even though such
	  attribute values cannot be translated, they are still likely
	  to be useful.
      In the case of a client, the attribute string may be used for
      local display of ownership.  However, in the case in which
      the server receives such a string, it is less likely to be useful
      and might be harmful in that its use by the server might
      undercut the value of the translation to the form name@domain.
      In order to avoid these negative effects:
	</t>
	<ul>
	  <li>
	    When a numeric value is received in an attribute being
	    set where an RPCSECGSS-based auth flavor is being used,
	    the SETATTR <bcp14>MUST</bcp14>
	    return an error (NFS4ERR_BADOWNER).
	  </li>
	  <li>
	    When the auth flavor AUTH_SYS is being used, the seerver
	    <bcp14>MAY</bcp14> accept user and groups identified
	    by ids using the string numeric form and return them in
	    that form. However, when it does so it still
	    <bcp14>MUST</bcp14> return these values, in the name@domain
	    form to those using other auth flavors.
	  </li>
	</ul>
        <t>
	  [Author Aside, Including List (Items #52a, #60a)]: Something
	  needs to be done
	  about the failure of the corresponding text in RFC8881 to
	  deal approriately with root@domain and nobody@domain, either
	  to exclude these or include them with appropriate explanations.
	  Specifically:
        </t>
	<ul>
	  <li><t>
	    With regard to the case of "nobody", the primary issue is
	    that "nobody@domain" is not addressed,
	    although "nobody", which should not occur, is.
	  </t><t>
	  A further difficulty is the use of the term "anonymous" with
	  the intention to include unidentified and unauthentcated users
	  as well as those which are not approrpriately authenticated.
	  </t></li>
	  <li><t>
	    With regard to the case of "root", the issue is not mentioned at
	    all, leaving it unclear as to whether this sort of
	    special handling is gone,
	    or is dependent now on the name "root" or the mumeric
	    id zero despite
	    the geneneral deprecation of numeric ids.
	  </t><t>
	  The possibility of support for multiple domains, creates
	  additional complexity whih needs to be addressed.
	  </t></li>
	</ul>
        <t>
	  [Consensus Needed (Item #60a)]:
      An owner string of the form "nobody@domain" may be used to designate an
      anonymous or unauthenticated user, which will be associated with 
      a file created by a security principal whose identity is not
      determinable or cannot be mapped through normal
      means to the Owner attribute.  Users and implementations
      of NFSv4.1 should avoid the use of the string "nobody" to identify
      an actual user.
	</t>
	<t>
	  [Consensus Needed (Item #52a)]: Certain id strings that map to
	  known numeric values such as zero <bcp14>MAY</bcp14> be assigned
	  special privileges with regard to operation authorization,
	  allowing operations to be authoized that POSIX or ACL-based
	  authentication might disallow.  The granting of such privileges
	  <bcp14>MUST NOT</bcp14> be based on the user name (e.g. "root").
	  Instead, the server <bcp14>MUST</bcp14> only use the principal id
	  or information returned by a secure id mapping facility in
	  assigning such privileges, which <bcp14>MAY</bcp14> be assigned
	  differently based on the reliability of the authentication method
	  used.  When multiple domains are supported, the privilege
	  assignments might be diffeent for diffeent domains, but the
	  mapping of ids into a value used internally by the file systen
	  is not to be considered in deciding about granting such
	  privileges.
	</t>

    </section>

     <section anchor="ATTR-table">
       <name>Table of Authorization-related Attributes</name>
       <t>
	 The list of authorization-related attributes appears in
	 <xref target="attr_table"/>.
       </t>
       <t>
	 The meaning of the columns of the table are:
       </t>
        <dl>
          <dt>Name:</dt>
          <dd>The name of the attribute.</dd>
          <dt>Id:</dt>
          <dd>
	    The number assigned to the attribute. In
            the event of conflicts between the assigned number and
	    minor version specification documents, the former is
            authoritative, but conflicts should be resolved with Errata to
            this document and/or the minor version specifcation document.
            See <xref target="errata"/> for the Errata process.
	  </dd>
          <dt>Data Type:</dt>
          <dd>The XDR data type of the attribute.</dd>
          <dt>Acc:</dt>
          <dd>Access allowed to the attribute. R means
        read-only (GETATTR may retrieve, SETATTR may not
        set). W means write-only (SETATTR may set, GETATTR
        may not retrieve).  R W means read/write (GETATTR
        may retrieve, SETATTR may set).</dd>
          <dt>Defined in:</dt>
          <dd>The section of this specification that describes the
        attribute.</dd>
        </dl>
        <table anchor="attr_table">
          <thead>
            <tr>
              <th>Name</th>
              <th>Id</th>
              <th>Data Type</th>
              <th>Acc</th>
              <th>Defined in:</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>acl</td>
              <td>12</td>
              <td>nfsace4&lt;&gt;</td>
              <td>R W</td>
              <td>
                <t>ACL document</t>
              </td>
            </tr>
	    <tr>
              <td>aclsupport</td>
              <td>13</td>
              <td>uint32_t</td>
              <td>R</td>
              <td>
                <t>ACL document</t>
              </td>
            </tr>
            <tr>
              <td>dacl</td>
              <td>58</td>
              <td>nfsace4&lt;&gt;</td>
              <td>R W</td>
              <td>
                <t>ACL dicument</t>
              </td>
            </tr>
            <tr>
              <td>mode</td>
              <td>33</td>
              <td>uint32_t</td>
              <td>R W</td>
              <td>
                <xref target="ATTR-mode"/>
              </td>
            </tr>
            <tr>
              <td>mode_set_masked</td>
              <td>74</td>
              <td>mode_masked4</td>
              <td>__W</td>
              <td>
                <xref target="ATTR-modesm"/>
              </td>
            </tr>
            <tr>
              <td>owner</td>
              <td>36</td>
              <td>utf8str_mixed</td>
              <td>R W</td>
              <td>
                <xref target="ATTR-owner"/>
              </td>
            </tr>
            <tr>
              <td>owner_group</td>
              <td>37</td>
              <td>utf8str_mixed</td>
              <td>R W</td>
              <td>
                <xref target="ATTR-ogroup"/>
              </td>
            </tr>
            <tr>
              <td>sacl</td>
              <td>59</td>
              <td>nfsace4&lt;&gt;</td>
              <td>R W</td>
              <td>
                <t>ACL document</t>
              </td>
            </tr>
            <tr>
              <td>sec_label</td>
              <td>80</td>
              <td>sec_label4</td>
              <td>R W</td>
              <td>
                <xref target="ATTR-seclabel"/>
              </td>
            </tr>
          </tbody>
        </table>
     </section>

     <section anchor="ATTR-posix">
       <name>POSIX-oriented Authorization-related Attributes</name>

       <t>
	 [Consensus Needed (Item #57d)]: The <bcp14>REQUIRED</bcp14>
	 attributes Owner,
	 Owning_group, and Mode enable use of a POSIX-based
	 authorization model, as described in
	 <xref target="AUTHFA-posix"/>.
	 Given that all of these attributes <bcp14>MUST</bcp14> be supported,
	 this authorization model is always available.
       </t>
       <t>
	 These attributes are also of use when ACL-based authorization is
	 in effect.
       </t>
       <ul>
	 <li><t>
	   The values of the Owner and Owner_group attributes affect
	   the interpretation of the special "who" values "@OWNER" AND
	   "@GROUP">
	 </t></li>
	 <li><t>
	   Changes to the acl and dacl attributes will often result
	   in corresponding changes to the mode attribute.
	 </t></li>
	 <li><t>
	   Setting the mode attribute will often override the values in
	   acl and dacl attributes, even if tere has been no changes
	   to the authorzation-related bits.
	 </t><t>
	   The set_mode_masked attribute can be set when changing
	   bits in the mode, if the authorization-related bits
	   are not to be changed and there is a need not to update
	   authorization-related ACEs. 
	 </t></li>
       </ul>

       <section anchor="ATTR-mode">
	 <name>The Mode Attribute (v4.0)</name>
	 <t>
	   [Consensus needed (Item #6a)]:  This field is limited to
	   twelve bits, of which only the low-order
	   ten bits are authorization-related. Of the lowest-order
	   nine bit, each set of three
	   bits controls
	   the actions authorized for the file object by a particular
	   set of users.  Proceding from higher-order bits to lower,
	   these sets are:
	 </t>
	 <ul>
	   <li>
	     The user that is owner of the file.
           </li>
           <li>
	     Any user within the owning user group other than the owner 
	     of the file.
           </li>
           <li>
	     All other users.
           </li>
	 </ul>
	 <t>
	   Once the appropriate set is determned, based on the principal
	   making
	   the request, the corrsponding three bits determine operation
	   authorization as follows:
	 </t>
	 <ul>
           <li>
	     Authorization for reading of data from the file is controlled
	     by the highest-order bits, as is reading the contents from a
	     directory.
           </li>
           <li>
	     Authorization for writing of data to the file is controlled by 
	     the second-highest-order bit, as is modifying the contents of 
	     a directory using REMOVE, RENAME, CREATE and OPEN of file
	     specfiying
	     creation of a new file.
           </li>
           <li>
	     Authorization for read of data from the file for the purposes
	     of
	     executing it as code (eiter via loading/execution of machine
	     instructions or by interpretation of scripts
	     is controlled by the
	     lowest-order bit.  Similarly, in the case of a directory, this
	     bit
	     controls the searching of the directory to open
	     the file,
	     do a LOOKUP, or do ny other operation that involves
	     searchin a direcory for a specific name
           </li>
	 </ul>
	 <t>
	   The specfication of the individulal mode bits appears below:
	 </t>
          <sourcecode type="xdr">
const MODE4_SUID = 0x800;  /* set user id on execution */
const MODE4_SGID = 0x400;  /* set group id on execution */
const MODE4_SVTX = 0x200;  /* save text even after use */
const MODE4_RUSR = 0x100;  /* read permission: owner */
const MODE4_WUSR = 0x080;  /* write permission: owner */
const MODE4_XUSR = 0x040;  /* execute permission: owner */
const MODE4_RGRP = 0x020;  /* read permission: group */
const MODE4_WGRP = 0x010;  /* write permission: group */
const MODE4_XGRP = 0x008;  /* execute permission: group */
const MODE4_ROTH = 0x004;  /* read permission: other */
const MODE4_WOTH = 0x002;  /* write permission: other */
const MODE4_XOTH = 0x001;  /* execute permission: other */
</sourcecode>
          <t>
          Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR apply to the
          principal identified by the owner attribute. Bits MODE4_RGRP,
          MODE4_WGRP, and MODE4_XGRP apply to principals belonging to
	  the group identified in
          the owner_group attribute but who are not identified by the
          owner attribute. Bits MODE4_ROTH, MODE4_WOTH, and MODE4_XOTH apply
          to any principal that does not match that in the owner
          attribute and does not belong to a group matching that of the
          owner_group attribute.  These nine bits are used in providing
	  authorization information.
          </t>
          <t>
	    [Previous Treatment]: The bits MODE4_SUID, MODE4_SGID, and
	    MODE4_SVTX do not
	    provide authorization information and do not affect server
	    behavior.  Instead, they are acted on by the client just as
	    they would be for corresponding mode bits obtained from
	    local file systems.
          </t>
          <t>
	    [Consensus needed (Item #6a)]: For objects which are not
	    directories, the bits MODE4_SUID,
	    MODE4_SGID,
	    and MODE4_SVTX do not
	    provide authorization information and do not affect server
	    behavior.  Instead, they are acted on by the client just as
	    they would be for corresponding mode bits obtained from
	    local file systems.
          </t>
          <t>
	    [Consensus needed (Item #6a)]: For directories, the bits
	    MODE4_SUID and MODE4_SGID,
	    do not
	    provide authorization information and do not affect server
	    behavior.  Instead, they are acted on by the client just as
	    they would be for corresponding mode bits obtained from
	    local file systems.  The mode bit MODE_SVTX does have an
	    authorization-related role as described later in this section
          </t>
          <t>
	    [Consensus Needed, Including List (Item #6a]): When handling
	    RENAME and REMOVE operations the check for authorization depends
	    on the setting of MODE_SVTX for the directory.
          </t>
	  <ul>
	    <li>
	      When MODE_SVTX is not set on the directory, authorization
	      requires
	      write permission on both the file being renamed and the source
	      directory.
	    </li>
	    <li>
	      When MODE_SVTX is set on the directory,
	      authorization requires,
	      in addition, that the requesting principal be the owner of the
	      file to be renamed or removed.
	    </li>
	  </ul>
          <t>
	    [Consensus needed (Item #6a)]: It needs to be noted that
	    this approach is similar to the ACL-based
	    approach documented in ACLSPEC(ACL-deletes).  However
	    there are  some semantic differences whose motivation remains
	    unclear and the specification does not mention RENAME,
	    as it needs to.
          </t>
          <t>
	    [Author Aside]: Bringing the above into more alignment with
	    the ACL-based semantics is certainly desirable but the
	    necessary work has not been done yet.  For tracking purposes,
	    that realignment will be considered as Consensus Item #20.
          </t>
          <t>
          Bits within a mode other than those specified above
          are not defined by this protocol. A server
          <bcp14>MUST NOT</bcp14> return bits other than those defined above 
          in a GETATTR or READDIR operation, and it <bcp14>MUST</bcp14>
	  return NFS4ERR_INVAL
          if bits other than those defined above are set in a SETATTR,
          CREATE, OPEN, VERIFY, or NVERIFY operation.
          </t>
          <t>
	    [Consensus Needed (Item #21b)]: 
	    As will be seen in Sections
	    ACLSPEC(AUTHCOMB-computemode)
	    and ACLSPEC(AUTHCOMB-setmode,
	    many straightforward ways
	    of dealing with mode that work well with forward-slope
	    modes need adjustment to
	    properly deal with reverse-slope modes, as defined in
	    <xref target="INTRO-term"/>
	    
          </t>
	 
       </section>
	 <section anchor="ATTR-modesm">
	 <name>The Mode_set_masked Attribute (v4.1)</name>
          <t>
            The mode_set_masked attribute is an <bcp14>OPTIONAL</bcp14>
	    write-only attribute 
            that allows individual bits in the mode attribute to be
            set or reset, without changing others.  It allows, for
            example, the bits MODE4_SUID, MODE4_SGID, and MODE4_SVTX
            to be modified while leaving unmodified any of the 
            nine low-order mode bits devoted to permissions. 
          </t>
	 <t>
	   When this attribute is
	   not supported, clients' only option in setting the mode
	   attribute is
	   to set all bits of that attribute using SETATTR, even if the
	   motivation is only to modify bits which are not
	   authorization-related.
	 </t>
	 <t>
	   This has the unfortunate result that some the effects of any
	   assciated ACL attribute are negated as it is assumed that by
	   changing
	   the mode, the intention is to override all ACL-related
	   authorization, whereever its
	   effect
	   is different from that specified by the mode alone.
	 </t>
         </section>

	 <section anchor="ATTR-owner">
	   <name>The Owner Attribute (v4.0)</name>
	   <t>
	     Defines the user who owns the file, which affects which
	     set of three bits from the mode attribute controls
	     the bits controlling authorizetio.
	   </t>
	   <t>
	     The interpretation of this string value is described in
	     <xref target="ATTR-idstrings"/>
	   </t>
	 </section>

	 <section anchor="ATTR-ogroup">
	   <name>The Owner_group Attribute (v4.0)</name>
	   <t>
	     Defines the group that wns the file, which affects which
	     set of three bits from the mode attribute controls
	     the bits controlling authorizetio.
	   </t>
	   <t>
	     The interpretation of this string value is described in
	     <xref target="ATTR-idstrings"/>
	   </t>
	 </section>
	 <section anchor="AUTHFA-posix-na">
	   <name>POSIX-based Authorization for Named Attributes</name>

	   <t>
	     [Author Aside (Item #66a), Through rest of Section}:
	     For the most part, the NFSv4 specfifications have avoided
	     the need to describe authorization semantics, by relying on
	     the POSIX definition and making it the responsibility of the
	     protocol, as it should be, to duplicate local semantics when
	     used remotely.
	   </t>
	   <t>
	     In the case of the <bcp14>OPTIONAL</bcp14> named attributes
	     feature which is ouside the scope of POSIX, that approach is
	     no longer viable and needs to supplementaed by a semantic
	     description. In formulating such description, the following
	     issued need to be addressed:
	   </t>
	   <ul>
	     <li><t>
	       We don't have information about authorization semantics
	       for implemementations of this feature or even if such
	       implementations exist.
	     </t><t>
	       This applies to both potential implementations that do and
	       do not support ACLs.
	     </t><t>
               The lack of previous focued discussion of this issue
	       strongly suggests that implementations are either
	       non-existent, or pay no serious attention to
	       authorizaton semantics.
	     </t></li>
	     <li><t>
	       The privilege structure provided by the <bcp14>REQUIRED</bcp14>
	       attributes Mode, Owner, and Owner_group seems like it
	       could be adapted to control access to the named attribute, but
	       there are some troublesome gaps.
	     </t><t>
	       OPENATTR provides no way to set the attributes for the
	       mamed attribute directory it creates.  Furthermore, GETTATTR
	       and SETATTR  on these directories are undefined, according
	       to <xref target="RFC8881"/>).
	     </t></li>
	     <li><t>
	       There are corresponding issues relating ACL-based
	       authorization that are part of the associated Consensus
	       Item #20A which is discussed within
	       <xref target="I-D.dnoveck-nfsv4-acls"/>.
	     </t><t>
	       There will need to be extensive co-ordination in addressing
	       these two related issues.
	     </t></li>
	   </ul>
	 </section>
       </section>

	 <section anchor="ATTR-aclr">
	   <name>ACL-based Authorization-related Attributes</name>
	   <t>
	     The following ACL-related attributes (all
	     <bcp14>OPTIONAL</bcp14> are described in detail in
	     the new document devoted to ACL handling
	     <xref target="I-D.dnoveck-nfsv4-acls"/>.
	   </t>
	   <ul>
	     <li>
	       The per-fs Aclsupport attribute.
	     </li>
	     <li>
	       The per-fs Aclfeatures attribute being added as an extension
	       to NFSv4.2..
	     </li>
	     <li>
	       The per-object Acl attribute.
	     </li>
	     <li>
	       The per-object Dacl attribute added in NFSv4.1..
	     </li>
	     <li>
	       The per-object Sacl attribute added in NFSv4.1
	     </li>
	   </ul>
	 </section>


      <section anchor="ATTR-mac">
	<name>Authorization-related Attributes for MAC</name>
	
	<section anchor="ATTR-seclabel">
	  <name>The Seclabel Attribute (v4.2)</name>
	  <t>
	    This opaque attribute provides authorization-related information to
	    support Mandatory Access Control.  Given the lack of specfic
	    docuentation about the contents and the uncertainty regarding
	    idenification of the actors making the requests to be authorized,
	    client-server interoperability is not available and any any
	    authorization decision are the responsibility of the client itself.
	  </t>
	  <t>
	    [Consensus needed (Item #58b)]: Although this was intended
	    to be an
	    OPTIONAL attribute, it is now more appropriate to describe
	    it is an under-specfied one, and thus essentially experimental,
	    although still formally.
	    <bcp14>OPTIONAL</bcp14>.
	    This is due to the absence of specifications
	    for the content of the attribute, or descriptions of
	    the way in which it is to
	    be used to govern authorization.
	  </t>
        </section>
      </section>
    </section>

   <section anchor="ACL">
    <name>Introduction to ACLs</name>
      <t>
        The ACL-related atributes Acl, Sacl, and Dacl, introduced above
	in <xref target="ATTR-aclr"/> and in more detail in the ACL
	specification document <xref target="I-D.dnoveck-nfsv4-acls"/>,
	each contain an array of Access Control Entries.  These ACEs
	define the operations that are authorized for paticular users or
	user groups
      </t>
      <t>
	ACL-related attributes and the structure of ACEs are described in
	detail in a companion document
	<xref target="I-D.dnoveck-nfsv4-acls"/>.
      </t>
      <section anchor="ACL-prev">
	<name>Previous Treatment of ACLs</name>
	<t>
	  The description of ACL-related attributes and ACEs that
	  appeared in previous documents embodied a flawed appoach to
	  protocol description that makes in unsuitable for use as a
	  basis for a descrption intended to appear and in a
	  standards-track document.  As the goal of this effort is to
	  produce a helpful standards-track document, these item will
	  be described using a new approach, as described in
	  <xref target="ACL-approach"/>.
	</t>
	<t>
	  This same approach was used in a number of documents published
	  as Proposed Standards, despite its flaws.  These included
	  RFCs now obsoleted (<xref target="RFC3010"/>,
	  <xref target="RFC3530"/>, and <xref target="RFC5661"/>) and a number
	  RFCs to be obsoleted when this document is published as an RFC
	  (<xref target="RFC7530"/> and <xref target="RFC8881"/>).
	  Although some changes were made in the transition between minor
	  versions, the essence of the approach remained the same.
	</t>
	<t>
	  The goal that led to this flawed approach remains as it was.
	  There is need to support an extended ACL model, with a fine-grained
	  permission model and other helpful extensions togther with
	  providing support for a more limited ACL model with a more direct
	  connection to POSIX semantics, very similar to that defined in
	  the withdrawn POSIX ACL draft implemented by a number of file
	  sytems implemented on UNIX systems. 
	</t>
	<t>
	  The approach actually taken to this need had the folloing
	  elements:
	</t>
	<ul>
	  <li>
	    The definition of the Acl attribute was based on the
	    extended ACL model, rather than simpler, more POSIX-oriented
	    core.
	  </li>
	  <li><t>
	    To allow servers implement the UNIX ACL subset to be
	    considered compliant, the specification was written
	    providing an unacceptable degree of leeway for the
	    server to implement many elements in pretty much whatever
	    way it chose.
	  </t><t>
	    This approach allowed UNIX ACls, NFSv4 ACLs and hybrids
	    of the two to be considerd compliant, as well as many
	    many unantcipated vaiants.  In any case, the client had no
	    way of determining the ACL semantics being implemented.
	  </t></li>
	</ul>
      </section>
      <section anchor="ACL-approach">
	<name>New Approach to Treatment of ACLs</name>
	<t>
	  The new approach, which will be explained in more detail in
	  the companion document <xref target="I-D.dnoveck-nfsv4-acls"/>
	  takes a very different approach, with the following chacteristics:
	</t>
	<ul>
	  <li><t>
	    The UNIX ACL subset is the basis of the canonical
	    description which can asssume is available, if the Acl
	    attribute is supported.
	  </t></li>
	  <li><t>
	    Additions to this core are treated as <bcp14>OPTIONAL</bcp14>
	    extensions. each of which might or might not be suported by
	    a server implementing the Acl atribute.
	  </t></li>
	  <li><t>
	    A new per-fs <bcp14>OPTIONAL</bcp14> attribute is defined to
	    allow clients to determine which ACL model extensions are
	    supported, if any.
	  </t></li>
	</ul>
	<t>
	  This new approach is embodied in the companion document
	  <xref target="I-D.dnoveck-nfsv4-acls"/>.  As a result, that
	  document has two functions:
	</t>
	<ul>
	  <li><t>
	    Together with this document it defines security for all
	    minor versions, updating <xref target="RFC7530"/> and,
	    together with the other rfc5661bis documents, onsoleteing
	    <xref target="RFC8881"/>.  This applies to all NFSv4 minor
	    versions.
	  </t></li>
	  <li><t>
	    Defining an extension that allows clients to determine the
	    ACL extensions supported by any given file system.  This
	    applies to nFSv4.2 and subsequent minor versions.
	  </t></li>
	</ul>	
	  
      </section>
   </section>
   <section anchor="AUTHG">
    <name>Authorization in General</name>
    <t>
      There are three distinct methods of checking whether NFSv4 requests
      are authorized:
    </t>
    <ul>
      <li><t>
	The most important methods of authorization is used to effect
	user-based file access control, as described in
	<xref target="AUTHFA"/>.  These methods are often termed
	"Discretionary access control" because they rely on attributes set
	by particular users, to control acceptable file access.
      </t><t>
        This requires the identification of the user making the request.
        Because of the central role of such access control in providing
	NFSv4 security, server implementations <bcp14>SHOULD NOT</bcp14>
	use such identifications when they are not authenticated. In this
	context, valid reasons to do otherwise are limited to the
	compatibility and maturity issues discussed in
	<xref target="SECCON-changes-compat"/>
      </t><t>
      </t></li>
      <li><t>
	NFSv4.2, via the labelled NFS feature, provides an additional
	potential requirement for request authorization.  The labelled
	NFS provides "Mandatory access control" not under the control
	of individual users.
      </t><t>
        For reasons made clear in <xref target="AUTHL"/>, there
        is no realistic possibility of the server using the data defined
	by existing specifications of this feature to effect request
	authorization.  While it is possible for clients to provide
	this authorization, the lack of detailed specifications makes it
	impossible to determine the nature of the identification used and
	whether it can appropriately be described as "authentication".
      </t></li>
      <li><t>
	Since undesired changes to server-maintained locking state (and, for
	NFSv4.1, session state) can result in denial of service attacks
	(see <xref target="SECTHREAT-denial"/>), server implementations
	<bcp14>SHOULD</bcp14> take steps to prevent unauthorized state
	changes. This can be done by implementing the state authorization
	restrictions discussed in <xref target="AUTHST"/>.   Because these
	restrictions apply on a per-peer basis rather than being affected
	by the identity of the user making the request,  it is better
	to consider them  as part of "Mandatory access control".
      </t><t>
        
      </t></li>
    </ul>
  </section>
      <section anchor="AUTHFA">
	<name>User-based File Access Authorization</name>
        <section anchor="AUTHFA-attr">
	  <name>Attributes for User-based File Access Authorization</name>
	  <t>
	    NFSv4.1 provides for multiple authentication models,
	    controlled by the support for particular recommended attributes
	    implemented by the server, as discussed below:
	  </t>
	  <ul>
	    <li><t>
	      Consensus Needed (Item #57e)]: The <bcp14>REQUIRED</bcp14>
	      attributes owner, owning_group, and mode enable use of a
	      POSIX-based
	      authorization model, as described in
	      <xref target="AUTHFA-posix"/>.
	      Since these attributes are always supported, this
	      authorization model is aways available.
	    </t></li>  
	    <li><t>
	      [Consensus Needed (Item #17a)]: The acl attribute (or the
	      attribute dacl in NFSv4.1) can
	      provide an ACL-based authorization model as described in
	      <xref target="AUTHFA-acl"/> as long as support for ALLOW and
	      DENY ACEs is provided.
	    </t><t>
	      [Consensus Needed (Items #17a)]: When some of
	      these ACE types are
	      not supported attribute, this authorization model
	      is unavailable, since there are some modes that cannot be
	      represented as a corresponding NFSv4 ACL, when using only a single ACE
	      type.  See ACLSPEC(AUTHCOMB-attr) for details
	    </t></li>  
	  </ul>
        </section>
	<section anchor="AUTHFA-two"> 	
	  <name>Handling of Multiple Parallel File Access Authorization Models</name>
	  <t>
            NFSv4 ACLs and modes represent two well-established models for
            specifying user-based file access permissions.  NFSv4 provides
	    support for either or both depending on the attributes
	    supported by the server and, in cases in which both
	    NFSv4 ACLs and the mode attribute
	    are supported, the actual attributes set for a particular object.
	  </t>
	  <ul>
	    <li><t>
	      [Consensus Needed (item #18b)]:
	      When the attributes mode, owner, owner group are all supported,
	      the posix-based
	      authorization model, described in <xref target="AUTHFA-posix"/>
	      can be used.
	    </t></li>
	    <li><t>
	      [Consensus Needed (Items #17b, #18b)]:
	      When the acl (or dacl) attribute is supported together with
	      both of the ACE types ALLOW and DENY, the acl based
	      authorization model, described  in <xref target="AUTHFA-acl"/>
	      can be used as long as the attributes owner and owner_group are
	      also supported.
            </t></li>
	  </ul>
	  <t>
	    [Consensus Needed (item #18b)]:
	    While formally recommended (essentially <bcp14>OPTIONAL</bcp14>)
	    attributes, it appears that the owner and owner_group
	    attributes need to be available to support any file access
	    authorization model.  As a result, this document will not
	    discuss the possibility of servers that do not support
	    both of these attributes and clients have no need to
	    support such servers.
          </t>
	  <t>
	    When both authorization models can be used, there are
	    difficulties that can arise because the ACL-based model
	    provides finer-grained access control than the POSIX model.
	    The ways of dealing with these difficulties appear
	    later in this section while more detail on the appropriate
	    handling of this situation, which might depend on the minor
	    version used, appears in <xref target="AUTHCOMB"/>.
	  </t>
	  <t>
	    The following describe NFSv4's handling in supporting multiple
	    authorization models for file access.
          </t>
          <ul>
            <li><t>
              If a server supports the mode attribute, it needs to  provide
              the appropriate POSIX semantics if no ACL-based attributes
	      have ever been assigned to object.  These semantics include
	      the restriction of the ability to modify the mode, owner and
	      owner-group to the current owner of the file.
            </t></li>
            <li><t>
              If a server supports ACL attributes, it needs to provide
              NFSv4 ACL semantics as described in this document for all
	      objects for which the ACL attributes have actually been
	      set.  This includes the ACL-based restrictions on the
	      authorization to modify the mode, owner and owner_group
	      attributes.
            </t></li>	      
            <li><t>
              On servers that support the mode attribute, if ACL
              attributes have never been set on an object, via
              inheritance or explicitly, the behavior is to be
              the behavior mandated by POSIX, including tthose
	      provisions
	      that restrict the setting of authorization-related attributes.
            </t></li>
            <li><t>
              On servers that support the mode attribute, if the ACL
              attributes have been previously set on an object, either
              explicitly or via inheritance:
            </t>
            <ul>
              <li><t>
                [Previous Treatment]:
		Setting only the mode attribute should effectively
                control the traditional UNIX-like permissions of read,
                write, and execute on owner, owner_group, and other.
	      </t><t>
	        [Author Aside]: It isn't really clear
	        what the above paragraph means, especially as it governs
		the handling of aces designating specific users and groups
		which are not the owner and have no overlap with the owning
		group
	      </t><t>
	        {Consensus Needed (Item #19a)]:
	        Setting only the mode attribute, will result in the
		access of the file being controlled just it would be if
		the existing acl did not exist, with file access decisions
		as to read made in accordance with the mode set.   The
		ALLOW and DENY aces
		in the ACL will reflect the modified security although there
		is no need to modify AUDIT and ALARM aces or mask bits not 
		affected by the mode bits, such as SYNCHRONIZE. 
	      </t><t>
	        [Author Aside]:	the above may need to modified to reflect the
	        resolution of Consensus Item #??.
              </t></li>
              <li><t>
                [Previous Treatment]:
		Setting only the mode attribute should provide
                reasonable security. For example, setting a mode of
                000 should be enough to ensure that future OPEN operations for
                OPEN4_SHARE_ACCESS_READ or OPEN4_SHARE_ACCESS_WRITE by any
		principal fail, regardless of a
                previously existing or inherited ACL.
	      </t><t>
	        [Author Aside]:  We need to get rid of or provide some some replacement
	        for the subjective first sentence.  While the specific
		example give is unexceptionable, it raises questions in
		other cases as to what would constitutes "reasonable
		semantics". While the resolution of such questions would be
		subject to dispute, the author believes
		that consensus item #19a deals with the matter adequately.
		As a result he proposes, that the that this bullet be removed
		and that the second-level list be collapsed to a single
		paragraph.
              </t></li>	      
            </ul>
          </li>
          <li>
            Although <xref target="RFC7530"/> and
	    <xref target="RFC8881"/> present different descriptions
	    of the specific semantic requirements
            relating to the interaction of mode and ACL attributes,
	    the difference are quite small, with the most
	    important ones deriving from the absence of the set_mode_masked
	    attribute.   The unified treatment in <xref target="AUTHCOMB"/>
	    will indicate where version-specific differences exist.
          </li>
        </ul>
      </section>

        <section anchor="AUTHFA-posix">
	  <name>Posix Authorization Model</name>
	  <t>
	    Uses the <bcp14>REQUIRED</bcp14> attributes Mode, Owner, amd
	    Owner_group to authorize actions applying to files and
	    directories.  Aside from the conversion of Owner and
	    Owner_group to the forms of strings, this mirrors
	    authorization in NFSv3, in being based on semantics defined
	    by POSIX, originally used to control local finle access.
	  </t>
	  <t>
	    There are some potential differences to be notesd:
	  </t>
	  <ul>
	    <li><t>
	      The use of "owner-override" semanctics is allowed.  This
	      vaiant of autorization semantics was necessary in earlier
	      NFS vesions, to allow continued access to open files
	      even when the mode had been changed subequent to the open.
	    </t><t>
	      Even though it is no longer necessary because NFSv4 is a
	      stateful protocol, it is still allowed.
	    </t></li>
	    <li><t>
	      [Consensus needed (Item #6b)]:
	      The bit MODE_SVTX within the Mode attrbute on directories
	      affects the authorization of REMOVE and RENAME.
	    </t></li>
	  </ul>
        </section>
        <section anchor="AUTHFA-acl">
	  <name>ACL-based Authorization Model</name>
	  <t>
	    While the relevant details appear in
	    <xref target="I-D.dnoveck-nfsv4-acls"/>, this model can be
	    helpfully smmarize as follows:
	  </t>
	  <t>
	    The use of ACLs, via setting the <bcp14>OPTIONAL</bcp14>
	    attributes Acl and Dacl, allows a more flexible approch
	    to authorization in that the individual entries (ACEs) within the
	    ACL can assign different privileges to different users or groups
	    of users.
	  </t>
	  <t>
	    The ACEs within an ACL are examined in sequence with those
	    designating the user requesting or a group to which that
	    user belongs affecting the authorization decision to see
	    if a needed authorzation for the requested operation is granted,
	    or,
	    depending the ACE type, denied.
	  </t>
	  <t>
	    Once all requested autnorization are granted, the operation
	    is authorized and can proceed.  If any requested authorzation
	    is denied, the operation is not authotized.  In either case,
	    this terminates the processing of ACEs.
	  </t>
       </section>
       </section>
         <section anchor="AUTHCOMM">
	  <name>Common Considerations for Both File access Models</name>
          <t>
	    [Author Aside, Including List]: The subsections within this section are
	    derived from Section 6.3 of 8881, entitled "Common Methods.
	    However, its content is
	    different because it has been rewritten to deal with issues
	    common to both file access models, which now appears to have
	    not been the original intention.  Nevertheless, the following
	    changes have been made:
	  </t>
	  <ul>
	    <li><t>
	      The section "Server Considerations" has been revised  to
	      deal with both the mode and acl attributes, since the points
	      being made apply, in almost all cases, to both attributes.
	    </t></li>
	    <li><t>
	      The section "Client Considerations" has been heavily revised,
	      since what had been there did not make any sense to me.
	    </t></li>
	    <li><t>
	      The section "Computing a Mode Attribute from an ACL" has been
	      moved to ACLSPEC(AUTHCOMB-computemode) since it deals
	      with the
	      co-ordination of  the POSIX and ACL authorization models.
	    </t></li>
	  </ul>
	  <section anchor="AUTHCOMM-ops">
	    <name>Handling of ACCESS and OPEN Operations</name>
	    <t>
	      The primary means by which client-side users find out whether
	      particular operations are authorized is to attempt those
	      operations and have them executed successfully or rejected
	      with an error.   However, clients can use the ACCESS operation
	      to determine in advance whether operations are permitted
	      done without actually attempting those operations.
	    </t>
	    <t>
	      The use of the ACCESS operation is of particular importance
	      when ACLs exist.  This is due in part to the complexity of
	      the ACLs but also derives from cases in which the client
	      is incapable of determining whether a specific ACE applies
	      to a particular request, as when some of the special who-field
	      values are used in an ACE.
	    </t>
	    <t>
	      An additional difficulty precluding the client performing its
	      own interpretation of an ACL concerns the existing specifications'
	      lack of clear 
	      requirements for server support, making it difficult
	      for the client to determine how a server might choose to behave
	      in some cases.   Even if this lack of specificity were remedied by
	      clarifying the specification
	      servers would still exist that reflected the previously valid
	      scope of acceptable server behavior.   As a result, it
              is impossible for the client to predict determine
	      the choices a server might make without using ACCESS.
	    </t>
	    <t>
	      Similarly, the OPEN operation can determine acces
	      rights in advance of actual access.  There are two differences
	      from ACCESS that clients need to be aware of, since they might
	      require use of ACCESS in addition to OPEN or make the results of
	      OPEN incompatible with the results of attempting IO
	      operations.
	    </t>
	    <ul>
	      <li><t>
		The permission model of
		OPEN is coarser-grained than that provided for by ACCESS or
		the ACE masks defined as part of the definition of NFSv4 ACLs.
	      </t><t>
	        When reading files, the fact that OPEN treats requests to open
	        a file to read it and to execute it together
	        means that the client will need to do
		an ACCESS operation to determine whether particular reads are to
		be allowed.
              </t><t>
	        When writing files, the fact OPEN that does not distinguish
	        between
	        WRITEs which extend the file and those that modify
		bytes already written means that the client will need to get
		the permission information using ACCESS or be prepared to have
		some set
		of WRITES on a file open for Write rejected as unauthorized.
	      </t></li>
	      <li><t>
		[Consensus needed, Entire Bulleted Item (Item #23a)]:
		Just as with ACCESS, the granting of permission
		does not foreclose subsequent permission changes, there are
		good reasons for servers to provide ways of allowing IO
		allowed at OPEN time to continue even in the face of
		permission changes that would normally be expected to
		make the IO operation invalid.   These reasons derive from
		the fact that local operations work this way and that it is
		is often necessary for requests over NFSv4 to behave just as
		they would if done locally.  As a result, it is desirable
		for servers to provide this expected behavior in some way
		since application programs have come to depend on it.
	      </t><t>
	        One way of handling this situation is described in
	        <xref target="AUTHCOMM-server"/>.   It deals with the most
		common of these situations in which the owner of the is both
		writing a file and seeking to make it subsequently unwritable,
		and while it does not deal with all such situations,
		it has proven satisfactory for many NFS protocols over a
		long time period
	      </t><t>
	        Another way of dealing with this situation involves the
	        server explicitly using the stateid to reference a particular
 		open made by a user, and avoiding reverification of access
		for READs and WRITEs made by that user since that
		verification was made at OPEN time.   To do this safely,
		the server needs to have authenticated principals and
		client peers and, in order to prevent man-in-middle attacks,
		it s necessary for all connections 
		on which stateids are sent to provide encryption.
	      </t></li>
	    </ul>
	      
	    
	  </section>
          <section anchor="AUTHCOMM-server">
            <name>Server Considerations</name>
            <t> 
	      The server uses the  mode attribute or the acl attribute applying
	      the algorithm described in
	      ACLSPEC(AUTHFA-proc-ace) to determine whether an ACL
	      allows access to an object.
	    </t>
	    <t>
	      [Author Aside, Including List]: The list previously in this
	      section (now described as "Previous Treatment"
	      combines two related issues in a way which obscures the
	      very different security-related consequences of two distinct 
	      issues:
	    </t>
	    <ul>
	      <li><t>
	        In some cases an operation will be authorized but is not
		allowed for reasons unrelated to authorization.
	      </t><t>
	        This has no negative effect on security.	
	      </t></li>
	      <li><t>
		The converse case can have troubling effects on
		security which are mentioned in this section and discussed in
		more detail in <xref target="SECCON"/>
	      </t></li>
	    </ul>
	    <t>
	      [Author Aside, Including List]: The items in that list
	      have been dealt with as follows:
	    </t>
	    <ul>
	      <li><t>
                The first and sixth items fit under the first (i.e. less
		troublesome) of these
		issues.  They have have been transferred into an
		appropriate 
		replacement list.
	      </t></li>
	      <li>
		The third item is to be deleted since it does not
		manifest either of these issues.  In fact, it refers to
		the semantics already described in ACLSPEC(ACL-maskd). 
	      </li>
	      <li><t>
		The second, fourth and fifth items need to be addressed
		in a new list dealing with the potentially troublesome
		issues arising from occasions in which the access semantics
		previously described are relaxed, for various reasons.
	      </t><t>
	        Included are cases in which previous specifications
	        explicitly allowed this by using the term
		"<bcp14>MAY</bcp14>" and others in which the existence
		of servers manifesting such behavior was reported, with
		the implication that clients need to be prepared for
		such behavior.
	      </t></li>
	    </ul>
	    <t>	
	      [Previous Treatment, Including List (Items #22a, #41a, #52b)]:
	      However,
	      these attributes might not be
	      the sole determiner of access.  For example:
            </t>
            <ul>
              <li>
                In the case of a file system exported as read-only,
                the server will deny write access even though
                an object's file access attributes would  grant it.
              </li>
              <li>
                Server implementations <bcp14>MAY</bcp14> grant ACE4_WRITE_ACL
                and ACE4_READ_ACL permissions to prevent
                a situation from arising in which there is no valid
                way to ever modify the ACL.
              </li>
              <li>
                All servers will allow a user the ability to read
                the data of the file when only the execute
                permission is granted (e.g., if the ACL denies the
                user the ACE4_READ_DATA access and allows the user
                ACE4_EXECUTE, the server will allow the user to
                read the data of the file).
              </li>
              <li>
                Many servers implement "owner-override semantics" in
                which the owner of the object is allowed to
                perform accesses that are denied by the ACL or mode bits
                This may be helpful, for example, to allow users
                continued access to open files on which the
                permissions have changed.
              </li>
              <li>
                Many servers provide for the existence of a
                "superuser" that has privileges beyond
                an ordinary user.  The superuser may be able
                to read or write data or metadata in ways that would
                not be permitted by the ACL or mode attributes.
              </li>
              <li>
                A retention attribute might also block access otherwise
                allowed by ACLs (see Section 5.13 of
		<xref target="RFC8881"/>).
              </li>
            </ul>
	    <t>	
	      [Consensus Needed, Including List (Item #22a)]: It needs to be
	      noted that, even when an operation is authorized, it may be
	      denied for reasons unrelated to authorization.
	      For example:
	    </t>
            <ul>
              <li>
                In the case of a file system exported as read-only,
                the server will deny write access even though
                an object's file access attributes would authorize it.
              </li>
              <li>
                A retention attribute might also block access otherwise
                allowed by ACLs (see Section 5.13 of 
		<xref target="RFC8881"/>).
              </li>
            </ul>
	    <t>
	      [Author aside, including List, (Item #22a)]: Unlike other
	      cases in which previous specs have granted permission to
	      the server to expand allowed behavior, in the case of
	      "owner-override semantics", the need for supercession
	      does not arise from security issues but instead derives
	      from:
	    </t>
	    <ul>
	      <li><t>
		The unacceptable implication in the superseded text that
		the fact that a server chooses to do something, means that
		the client needs to accept that behavior.
	      </t></li>
	      <li><t>
		The lack of any definition of the term "owner-override
		semantics.   Subsequent investigation has led to the
		conclusion
	        that the semantics being referred to derive from the
		following material in <xref target="RFC1813"/>:
	      </t>
	      <ul empty="true">
		<li>
		   Another problem arises due to the usually stateful open
		   operation.  Most operating systems check permission at open
		   time, and then check that the file is open on each read and
		   write request. With stateless servers, the server cannot
		   detect that the file is open and must do permission checking
		   on each read and write call. UNIX client semantics of access
		   permission checking on open can be provided with the ACCESS
		   procedure call in this revision, which allows a client to
		   explicitly check access permissions without resorting to
		   trying the operation. On a local file system, a user can open
		   a file and then change the permissions so that no one is
		   allowed to touch it, but will still be able to write to the
		   file because it is open. On a remote file system, by
		   contrast, the write would fail. To get around this problem,
		   the server's permission checking algorithm should allow the
		   owner of a file to access it regardless of the permission
		   setting. This is needed in a practical NFS version 3 protocol
		   server implementation, but it does depart from correct local
		   file system semantics. This should not affect the return
		   result of access permissions as returned by the ACCESS
		</li>
	      </ul>
	      <t>
		As a result, it appears that NFSv4 servers have
		implemented semantics different from that provided for
		by POSIX that were defined in order to deal with lack of an open
		operation in NFsv3 in the context of NFSv4, which does
		have an open operation.
	      </t></li>
	      <li><t>
		The need to make it clear that an alternate approach to the
		issue of permission change after open is to allow the
		OPEN's permission check to be dispositive as long as
		the appropriate security infrastructure is in place to allow
		client stateids to be trusted.
	      </t></li>
	    </ul>
		
	    <t>	
	      [Consensus Needed, (Item #22a)]: There are 
	      also cases in which the converse issue arises, so that
	      an operation which is not authorized as specified by the
	      mode and ACL attributes is, nevertheless, executed as if
	      it were authorized. Because previous NFSv4 
	      specifications have cited the cases listed below
	      without reference to the security problems that they
	      create, it is necessary to discuss them here to
	      provide clarification of the security implications
	      of following this guidance, which might now be superseded.
	      These cases are
	      listed below and discussed in more detail in
	      <xref target="SECCON-changes-diverge"/>.
	    </t>
	    <t>
	      [Consensus Needed, Including List (Item #22a, #41a, #52b)]: 
	      In the following list, the treatment used in
	      <xref target="RFC8881"/> is
	      quoted, while the corresponding text in 
	      <xref target="RFC7530"/> is
	      essentially identical.
	    </t>
            <ul>
              <li><t>
		<xref target="RFC8881"/> contains the following,
		which is now superseded:
	      </t>
	      <ul empty="true">
		<li>
                  Server implementations <bcp14>MAY</bcp14> grant ACE4_WRITE_ACL
                  and ACE4_READ_ACL permissions to prevent
                  a situation from arising in which there is no valid
                  way to ever modify the ACL.
		</li>
	      </ul>
	      <t>
		While, as a practical matter, there do need to be provisions
		to deal with this issue, the "<bcp14>MAY</bcp14>" above is too
		broad,in that it describes the motivation without any limits
		providing appropriate restriction on the steps that might be
		taken to deal with the issue. See
		<xref target="SECCON-changes-diverge"/> for the updated
		treatment of this issue.
		
              </t></li>
              <li><t>
		<xref target="RFC8881"/> contains the following,
		which is now superseded:
	      </t>
	      <ul empty="true">
		<li>
                  Many servers implement owner-override semantics in
                  which the owner of the object is allowed to
                  override accesses that are denied by the ACL.
                  This may be helpful, for example, to allow users
                  continued access to open files on which the
                  permissions have changed.
		</li>
	      </ul>
	      <t>
		The principal problem with the above statement is the
		lack of a clear definition of the term "owner-override
		semantics".  Also, it needs to be
		made clear that the fact that a server manifests a
		particular behavior does not imply that it is valid according
		to the protocol specification.
	      </t><t>
	        In this case, investigation has led to the conclusion
	        that the semantics being referred to derive from the
		discussion of NFSv3 semantics appearing Section 4.4
		of <xref target="RFC1813"/> and that this handling
		has been implemented in a number of NFSv4 servers, despite the
		fact that NFSv4, unlike NFSv3, does have an open operation.
	      </t><t>
	        With regard to the second sentence of the quotation
	        above, it is not clear whether it is helpful or hurtful
		to allow continued access to open files which have become
		inaccessible due to changes in security
		and  it is not clear that the working group will make a
		decision on the matter in this document, despite the
		obvious security implications.  In any case, the resolution
		is unlikely to depend on whether the owner is involved.
	      </t><t>
	        Since this divergence from POSIX semantics is unlikely to
	        result in security issues, we can clarify the above
		by saying that
		a server <bcp14>MAY</bcp14> diverge from POSIX semantics
		by always allowing READ or WRITE to be done by the file owner
		but that this divergence <bcp14>MUST NOT</bcp14> affect the
		handling of OPEN and ACCESS.  It also needs to be noted
		that servers could address the issue of preventing permission
		change affecting that handling of READs and WRITEs of
		open files as described in <xref target="AUTHCOMM-ops"/>. 
	      </t></li>
              <li><t>
		<xref target="RFC8881"/> contains the following,
		which is now superseded:
	      </t>
	      <ul empty="true">
		<li>
                  Many servers have the notion of a
                  "superuser" that has privileges beyond
                  an ordinary user.  The superuser may be able
                  to read or write data or metadata in ways that would
                  not be permitted by the ACL or mode attributes.
		</li>
	      </ul>
	      <t>
		While many (or almost all) systems in which NFSv4 servers
		are embedded, have provisions  for
		such privileged access to be provided, it does not follow that
		NFSv4 servers, as such, need to have provision for
		such access.
	      </t><t>
	        Providing such access as part of the NFSv4 protocols, would
	        necessitate a major revision of the semantics of ACL including
		such troublesome matters as the proper handling of AUDIT and
		ALARM ACEs in the face of such privileged access.  
	      </t><t>
	        Because of the effect such unrestricted access might have in
	        facilitating and perpetuating attacks,
		<xref target="SECCON-changes-diverge"/> will the new
		approach to this issue, while 
		<xref target="SECTHREAT-scope"/>, will explain how
		such access is addressed in the threat analysis.
              </t></li>
            </ul>
	    
          </section>
          <section anchor="AUTHCOMM-client">
            <name>Client Considerations</name>
            <t>
              [Previous Treatment]: Clients <bcp14>SHOULD NOT</bcp14>
	      do their own access checks based on
            their interpretation of the ACL, but rather use the OPEN and
            ACCESS operations to do access checks. This allows the
            client to act on the results of having the server
            determine whether or not access is to be granted based on
            its interpretation of the ACL.
            </t>
	    <t>
	      [Author Aside]:  With regard to the use of
	      "<bcp14>SHOULD NOT</bcp14>" in the paragraph above, it is not
	      clear what might be valid reasons to bypass this recommendation.
	      Perhaps "<bcp14>MUST NOT</bcp14>" or "are not advised to"
	      would be
	      more appropriate. 
	    </t>
            <t>
              [Consensus Needed (Item #23b)]: Clients are not expected to
	      do their own access checks based on
            their interpretation of the ACL, but instead use the OPEN and
            ACCESS operations to do access checks, where this is possible.
	    This allows the
            client to act on the results of having the server
            determine whether or not access is to be granted based on
            its interpretation of the ACL, rather then the client's which
	    might be different.  For a full discussion of limitations
	    on the use of ACCESS and appropriate client approaches to
	    deal these limitations, see <xref target="AUTHCOMM-ops"/>.
	    
            </t>
	    
            <t>
              [Previous Treatment]: Clients must be aware of situations
	      in which an object's
            ACL will define a certain access even though the server
            will not enforce it. In general, but especially in these
            situations, the client needs to do its part in the
            enforcement of access as defined by the ACL.
	    </t>
	    <t>
	      [Author Aside]:  Despite what is said later,
	      the only such case I know of is the use of READ and EXECUTE
	      where the client, but not the server, has any means of
	      distinguishing these.   I don't know of any others.
	      If there were,
	      how could ACCESS or OPEN be used to verify access?
	    </t>
            <t>
	      [Consensus Needed (Item #23b)];
            Clients need to be aware of situations in which an object's
            ACL will define a certain access even though the server
            is not in position to enforce it because the server does
	    not have the relevant information, such as knowing whether a
	    READ is for the purpose of executing a file.
	    Because of such situations,
            the client needs to do be prepared to do its part in the
            enforcement of access as defined by the ACL.
	    </t>
	    <t>
	      To do this,
            the client will send the appropriate ACCESS operation
            prior to servicing the request of the user or application
            in order to determine whether the user or application
            is to be granted the access requested.
	    </t>
	    <t>
	    [Previous Treatment (Item #24a)]: For examples in
            which the ACL may define accesses that the server doesn't
            enforce, see <xref target="AUTHCOMM-server"/>.
            </t>
	    <t>
	      [Author Aside]:  The sentence above is
	      clearly wrong since that section is about enforcement the
	      server does do.  The expectation is that it will be deleted
	      as part of Consensus Item #24a.
            </t>
          </section>
        </section>
         <section anchor="AUTHCOMB">
	   <name>Combining Authorization Models</name>
	   <t>
	     The existence of multiple authorization models where ACLs
	     are supported raises a number of issue regarding how these
	     two models are to interact that are dealt with in
	     <xref target="I-D.dnoveck-nfsv4-acls"/>.  These
	     include:
	   </t>
	   <ul>
	     <li>
	       How the value of the mode attribute is to computed from the
	       ACL.
	     </li>
	     <li>
	       How the case of the mode and ACL both being set in the same
	       SETATTR are to be dealw with.
	     </li>
	     <li>
	       How ACLs are modified in response to changes in the mode
	       attribute.
	     </li>
	     <li>
               How the ACL mode is to be modified when the mode attribute
	       is set.
	     </li>
	   </ul>
        </section>
      <section anchor="AUTHL">
	<name>Labelled NFS Authorization Model</name>
	<t>
	  The attribute sec_label was intended to enable an authorization
	  model focused on Mandatory Access Contro.
	</t>  
	<t>
	  Not much can be said about this feature because the specification,
	  in the interest of flexibility, has left important features
	  undefined in order to allow future extension.   As a result, we have
	  something that is a framework to allow Mandatory Access Control
	  rather than one to provide it.  In particular, 
	</t>
	<ul>
	  <li><t>
	    The sec_label attribute, which provides the objects label has
	    no existing specification.
	  </t></li>
	  <li><t>
	    There is no specification of the format of the subject
	    labels or way to authenticate them.
	  </t></li>
	  <li><t>
	    As a result, all authorization takes place on the client,
	    and the server simply accepts the client's determination.
	  </t></li>
	</ul>
	<t>
	  This arrangements shares important similarities with AUTH_SYS.
	  As such it makes sense:
	</t>
	<ul>
	  <li><t>
	    To require/recommend that an encrypted connection be used.
	  </t></li>
	  <li><t>
	    To require/recommend that client and server peers mutually
	    authenticate as part of connection establishment.
	  </t></li>
	  <li><t>
	    That work be devoted to providing a replacement without the
	    above issues.
	  </t></li>
	</ul>
      </section>
      <section anchor="AUTHST">
	<name>State Modification Authorization</name>
	<t>
	  Modification of locking and session state data are not be done by
	  a client other than the one that created the lock.  For this
	  form of authorization, the server needs to identify and
	  authenticate client peers rather than client users.
	</t>
	<t>
	  Such authentication is not directly provided by any RPC
	  auth flavor.  However, RPC can, when
	  suitably configured, provide this authentication on a
	  per-connection basis.
	</t>
	<t>
	  NFSv4.1 defines a number of ways to provide appropriate
	  authorization facilities.   These will not be discussed in
	  detail here but the following points need to  be noted:
	</t>
	<ul>
	  <li><t>
	    NFSv4.1 defines the MACHCRED mechanism which uses the RPCSEC_GSS
	    infrastructure to provide authentication of the clients peer.
	    However, this is of no value when AUTH_SYS is being used.
	  </t></li>
	  <li><t>
	    NFSv4.1 also defines the SSV mechanism which uses the RPCSEC_GSS
	    infrastructure to enable it to be reliably determined whether
	    two different client connections are connected to the same client.
	    It is unclear whether the word "authentication" is appropriate in
	    this case.  As with MACHCRED, this is of no value when
	    AUTH_SYS is being used. 
	  </t></li>
	  <li><t>
	    Because of the lack of support for AUTH_SYS and for NFSv4.0,
	    it is quite desirable for clients to use and for servers to
	    require the use of client-peer authentication as part of
	    connection establishment.
	  </t></li>
	</ul>
	<t>
	  When unauthenticated clients are allowed, their  state is exposed to
	  unwanted modification as part of disruption or denial-of-service
	  attacks.  As a result, the potential burdens of such  attacks are felt
	  principally by clients who choose not to provide such authentication.
	</t>
      </section>
      <section anchor="OTHACL">
	<name>Other Uses of Access Control Lists</name>
	<t>
	  Whether the Acl or Sacl attributes are used, AUDIT and ALARM
	  ACEs provide security-related facilities separate from the
	  the file access authorization provided by ALLOW and DENY
	  ACEs
	</t>
	<ul>
	  <li><t>
	    AUDIT ACEs provide a means to audit attempts to access a specified
	    file by specified sets of principals.
	  </t></li>
	  <li><t>
	    ALARM ACEs provide a means to draw special attention to attempts
	    to access specified
	    files by specified sets of principals.
	  </t></li>
	</ul>
	<t>
	  Whichever attribute is used to store the relevant ACEs, only
	  these ACE types are processed while other types are ignored.
	  While the processsing of successive ACEs is simillar to that
	  described in <xref target="AUTHFA-acl"/>, these two scans
	  cannot be combined.  The authoriation-related scan needs to be
	  done first and the result of that checks, success or failue
	  is needed to govern the deletion (or not) of AUDIT and
	  ALARM ACEs.
	</t>
	
      </section>
    <section anchor="IDENT">
    <name>Identification and Authentication</name>
    <t>
      Various objects and subjects need to be identified for a protocol to
      function.   For it to be secure, many of these need to be authenticated
      so that incorrect identification is not the basis for attacks.
    </t>
    <section anchor="IDENT-auth">
      <name>Identification vs. Authentication</name>
      <t>
	It is necessary to be clear about this distinction which has been
	obscured in the past, by the use of the term "RPC Authentication
	Flavor" in connection with situation in which identification
	without authentication occurred or in which there was neither
	identification nor authentication involved.   As a result, we will
	use the term "Auth Flavors" instead
      </t>
    </section> 
    <section anchor="IDENT-items">
      <name>Items to be Identified</name>
      <t>
	Some identifier are not security-relevant and can used be used
	without authentication, given that, in the authorization
	decision, the object acted upon needs only to be properly
	identified
      </t>
      <ul>
	<li><t>
	  File names are of this type.
	</t><t>
	  Unlike the case for some other protocols, confusion of names that
	  result from internationalization issues, while an annoyance, are
	  not relevant to security. If the confusion between LATIN CAPITAL
	  LETTER O and CYRILLIC CAPITAL LETTER O, results in the wrong file
          being accessed, the mechanisms described in <xref target="AUTHFA"/>
	  prevent inappropriate access being granted.
	</t><t>
	  Despite the above, it is desirable if file names together with
	  similar are not transferred in the clear as the information
	  exposed may give attackers useful information helpful in
	  planning and executing attacks.
	</t></li>
	<li><t>
	  The case of file handles is similar.
	</t></li>
      </ul>
      <t>
	Identifiers that refer to state shared between client and server
	can be the basis of disruption attacks since clients and server
	necessarily assume that neither side will change the state corpus
	without appropriate notice.
      </t>
      <t>
	While these identifiers do not need to be authenticated, they are
	associated with higher-level entities for which change of the state
	represented by those entities is subject to peer authentication.
      </t>
      <ul>
	<li><t>
	  Unexpected closure of stateids or changes in state sequence values
	  can disrupt client access as no clients have provision to deal
	  with this source of interference.
	</t><t>
	  While encryption may make it more difficult to execute such attacks
	  attackers can often guess stateid's since server generally not
	  randomize them.
	</t></li>
	<li><t>
	  Similarly, modification to NFSv4.1 session state information can result
	  in confusion if an attacker changes the slot sequence by assuring
	  spurious requests.   Even if the request is rejected, the slot
	  sequence is changed and clients may
	  a difficult time getting back in sync with the server.
	</t><t>
	  While encryption may make it more difficult to execute such attacks
	  attackers can often guess slot id's and obtain sessinid's since
	  server generally do not randomize them.  
	</t></li>
	<li><t>
	</t></li>
      </ul>
      <t>
	it is necessary that modification of the higher-levell entities
	be restricted to the client that created them.
      </t>
      <ul>
	<li><t>
	   For NFSv4.0, the relevant entity is the clientid.
	</t></li>
	<li><t>
	   for NFSv4.1, the relevant entity is the sessionid.
	</t></li>
      </ul>
      <t>
	Identifiers describing the issuer of the request, whether in numeric
	or string form always require authentication.
      </t>
    </section> 
    <section anchor="IDENT-flavor">
      <name>Authentication Provided by specific RPC Auth Flavors</name>
      <t>
	Different auth flavors differ quite considerably, as discussed below;
      </t>
      <ul>
	<li><t>
	  When AUTH_NONE is used, the user making the request is neither
	  authenticated nor identified to the server.
	</t><t>
	  Also, the server is not authenticated to the client and has no
	  way to determine whether the server it is communicating with is
	  an imposter.
	</t></li>  
	<li><t>
	  When AUTH_SYS is used, the user making is the request identified
	  but there
	  no authentication of that identification.
	</t><t>
	  As in the previous case, the server is not authenticated to
	  the client and has no
	  way to determine whether the server it is communicating with is
	  an imposter.
	</t></li>  
	<li><t>
	  When RPCSEC_GSS is used, the user making the request is authenticated
	  as is the server peer responding.
	</t></li>  

      </ul>
    </section> 
    <section anchor="IDENT-conn">
      <name>Authentication Provided by other RPC Security Services</name>
      <t>
	Depending on the connection type used, RPC may provide additional
	means of authentication.
	In contrast with the case of RPC auth flavors,
	any authentication happens
	once, at connection establishment, rather than on each RPC request.
	As a result, it is the client and server peers, rather than individual
	users that are authenticated.
      </t>
      <ul>
	<li><t>
	  For many types of connections such as those created TCP without
	  RPC-with-TLS and RPC-over-RDMA version 1, there
	  is no provision for peer authentication.
	</t><t>
	  As a result use of AUTH_SYS using such connections is
	  inherently problematic.
	</t></li>  
	<li><t>
	  Some connection types provide for the possibility of mutual peer
	  authentication.  These currently include only those established
	  by RPC-with-TLS.  However, given the value of peer authentication,
	  there is reason to believe further means of providing such services
	  will be defined. 
	</t></li>  
      </ul>
    </section> 
  </section> 
  <section anchor="DATA">
    <name>Security of Data in Flight</name>
    <section anchor="DATA-flavor">
      <name>Data Security Provided by Services Associated with Auth Flavors</name>
      <t>
	The only auth flavor providing these facilities is RPCSEC_GSS.
	When this
	auth flavor is used, data security can be negotiated between client and
	server as described in <xref target="NEGO"/>.  However, when
	data security is provided for the connection level, as described in
	<xref target="DATA-conn"/>, the negotiation of privacy and integrity
	support, provided by the auth flavor, is unnecessary,
      </t>
      <t>
	Other auth flavors, such as AUTH_SYS and AUTH_NONE have no such data
	security facilities.   When these auth flavors are used, the only data
	security is provided on a per-connection basis.
      </t>
    </section> 
    <section anchor="DATA-conn">
      <name>Data Security Provided for a Connection by RPC</name>
      <t>
	RPC, in many case, provide data security for all transactions
	performed on a connection, eliminating the need for that security
	to be provided or
	negotiated by the selection of particular auth flavors, mechanisms, or
	auth-flavor-associated services.
      </t>
    </section> 
  </section>
  <section anchor="NEGO">
    <name>Security Negotiation</name>
    <t>
      [Author Aside]:  All unannotated paragraphs in this section are
      considered part of Consensus Item #32a.      
    </t>
    <t>
      Because of the availability of security-related services associated
      with the transport layer, the security negotiation process needs to be
      enhanced so that the server can indicate the connection-level services
      needed.   Without the addition of pseudo-flavors defining
      connection-level services needed, use of SECINFO would be limited
      to selection of a particular auth flavor with connection characteristics
      selected by a process of trial and error.
    </t>
    <t>
      When the SECINFO response does not indicate the connection chacteristics
      needed, either because it does not contain any of the pseudoflavors
      described below or because the only such pseudo-flavor is PFL_ANY,
      the client only knows the available auth flavors together with the
      auth-flavor-associated services and needs to use trial and error
      to determines the server requirments for connection-provided
      services, as described below:
    </t>
    <ul>
      <li><t>
	For each SECINFO entry the client attempts to make a connection
	with whatever connection characteristics that its (i.e. the
	client's) security policy requires.  When that connection
	is successfully established, it can be used to access the
	current portion of the server, as indicated by SECINFO or
	SECINFO_NONAME.
      </t><t>
        In many cases, this will be a connection without rpc-with-tls,
        while in other cases the client will require rpc-with-tls to be
	assured of encryption or of entryption with mutual peer
	authentication.
      </t></li>
      <li><t>
	If that connection cannot be established, because the server
	does no provide support for the requested characteristics, then
	the client moves on to the next auth-flavor entry.  If there are
	no further entry, this portion ofthe server namespace cannot
	be accessed.
      </t></li>
      <li><t>
	If the connection cannot be established because it is rejected
	by the server because of its security policy, the client takes
	note and proceeds to request addutional connection-level services
	on the next connection request.
      </t><t>
        For example, if the client attempts an RPC connection of the server's
        security policy does not allow that, the connection rejection will
	indicate to the client that use of rpc-with-tls is required.  If
	the server's policy allows non-tls connection but restricts the
	auth-flavors that may use such connections, the requests made
	with those flavors may be rejected and the slient will also
	try to establish an rpc-with-tls connection.
      </t><t>
        Similarly, when an rpc-tls-connection is attempted without mutual
        peer authentication, its rejection will resut in the client
	attempting to establish a connection with mutual peer
	authentication.
      </t><t>
        When the client and server are unabble to estanlish a mutually
        accptable connection to use with a specific auth-flavor, the
	client moves on to the next auth-flavor in the SECINFO response.
      </t></li>
    </ul>
    <t>
      In order for the server to better communicate its security policies
      to the client and limit the cases in which connections are
      established only to be rejected due ti inapproprriate connection
      characteristics, the followin pseudo-flavor can be used in the
      response to SECINFO and SECINFO_NONAME requests.
    </t>
    <ul>
      <li><t>
	PFL_CRYPT indicates that encryption, such as thar provided by
	rpc-with-tls is to be required on any connection to support
	access to the current portion of the server namespace.
	
      </t></li>
      <li><t>
	PFL_CRYPTMPA indicates that encryption such as that provided by
	rpc-with-tls is to be required together with mutual peer
	authentication on any connection to support
	access to the current portion of the server namespace.
      </t></li>
      <li><t>
	PFL_ANY indicates that, for subsequent auth-flavors, there are
	no connection-based restritios to be assumed by the client,
	allowing connections that do not use encryption to be used as
	well as those that do.
      </t></li>
    </ul>
    <t>
      When any of these flavors are incuded in a SECINFO or SECINFO_NONAME
      response, the procEdure described above is modified as follows:
    </t>
    <ul>
      <li><t>
	When scanning the response, if pseudo-flavor entries are encountered,
	the client takes note of them, keeping track of the last such
	entry encountered.
      </t></li>
      <li><t>
	When processing a flavor entry in the response, the most recent
	pseudo-flavor is used in establishing the connection to be used,
	to avoid using connection that the server;s scurity policy will
	not allow to be used.  The initial connection characteristics used
	will be a rhose that meets the requiremnts specified by the
	pseudo-flavor
	and is consistent with the client's security policy.
      </t></li>
    </ul>
    <t>
      As an example of how these pseudoflavors can be used, consider
      a situation in which it is the server's
      security to only accept encrypted requests, whether the encryption
      is provide by RPCSEC_GSS or by rpc-with-tls.   A response consisting of
      the following entries will specify this behavior so the client can
      connect appropriately.
    </t>
    <ul>
      <li><t>
	PFL_CRYPT to indicate that the following auth-flavor entry, in this
	case AUTH_SYS, is to be imited to use on connection that provide
	encryption of requests and responses.
      </t></li>
      <li><t>
	AUTH_SYS indicates that use of the auth-flavor AUTH_SYS is
	acceptable to access the current potiono of the server bamespace.
	Because of the preceeding PFL_CRYPT, the client knows that this
	is only accepted on encrypted connections.
      </t><t>
        If the server supports rpc-with-tls and allows its use together
        with AUTH_SYS, this connection is used.  Otherwise processing
	proceeds to use subsequent entries.
      </t></li>
      <li><t>
	PFL_ANY to indicate that the subsequent auth-flavor entry, in this
	case RPCSEC_GSS, is not limited to any particular connection type.
      </t></li>
      <li><t>
	RPC_SECGSS indicating the requirement for encryption provided by
	rpcsec_gss.
      </t></li>
    </ul>
      <section anchor="NEGO-char">
      <name>Dealing with Multiple Connections</name>
      <t>
        [Author Aside]:  All unannotated paragraphs in this section are
        considered part of Consensus Item #32b.      
      </t>
      <t>
	Because effective security will require both an appropriate auth
	flavor (and possibly services provide by the auth flavor) together
	with appropriate connection characteristics, it is often
	necessary that clients and server be aware of connection
	characteristics:
      </t>
      <ul>
	<li><t>
	  When multiple connections with different security-related
	  characteristics, are used to access a server,
	  the clients needs to ensure that each request
	  is issued on an appropriate connection. 
	</t></li>
	<li><t>
	  Similarly, in such situations, the server needs to be aware of
	  the security-related characteristics for the connection on
	  which each request is received, in order to enforce its
	  security policy.
	</t></li>
      </ul>
      <t>
	Depending on how the client and server implementations are
	structured, implementations may have to be changed to accomplish
	the above.
      </t>
      <t>
	In the case of NFSv4.1 and above, the protocol requires that requests
	associated with a given session only be issued on connections
	bound to that session and accepted by the server only when that binding
	is present.  This makes it likely that clients or servers will be
	able to correctly associate requests with the appropriate
	connections although additional work might be necessary to enable them
	to determine, for any given connection, its security characteristics.
      </t>
      <t> 
	In the case of NFSv4.0, no such binding is present in the
	protocol so that, depending on existing implementations' layering,
	channel binding functionality might have to be added.
      </t>
    </section>
  </section>
  <section anchor="FUTURE">
    <name>Future Security Needs</name>
    <t>
      This section deals with weaknesses in the security of the existing
      protocol which might be dealt with in future minor versions or in
      extensions to existing minor versions.  Whle potential improvements
      to NFSv4 security are discussed in <xref target="FUTURE-base"/>
      the details of these extnsions are not specified and will, when the
      workin group decdes to implement them, in new standrards-track extension
      documents.
    </t>
    <t>
      Not discussed in this section are the extensions provided to
      inform of the specfics of the ACL semantic implemented by
      particular file system
    </t>
      
      <section anchor="FUTURE-base">
      <name>Desirable Additional Security Facilities</name>
      <t>
        [Author Aside]:  All unannotated paragraphs in this section are
        to be considered part of Consensus Item #35a.
      </t>
      <t>
	[Author Aside]:  This section is basically an outline
	for now, to be filled out later based on Working Group input,
	particularly from Chuck Lever who suggested this section and has ideas
	about many of the items in it. 
      </t>
      <ul>
	<li><t>
	  Security for data-at-rest, most probably based on facilities defined
	  within SAN.
	</t></li>
	<li><t>
	  Support for content signing.
	</t></li>
	<li><t>
	  Revision/extension of labelled NFS to provide true interoperability
	  and server-based authorization.
	</t></li>
	<li><t>
	  Work to provide more security for RDMA-based transports.  This would
	  include the peer authentication infrastructure now being developed
	  as part of RPC-over-RDMA version 2.   In addition, there is a need
	  for an RDMA-based transport that provides for encryption, which might
	  be provided in  number of ways.
	</t></li>
      </ul>
    </section>

  </section>
  <section anchor="SECCON">
    <name>Security Considerations</name>
    <section anchor="SECCON-changes">
      <name>Changes in Security Considerations</name>
      <t>
	Beyond the needed inclusion of a threat analysis as
	<xref target="SECTHREAT"/> and the fact that
	all minor versions are dealt with together, the Security
	Considerations in this section differ substantially from
	those in 
	<xref target="RFC7530"/> and
	<xref target="RFC8881"/>.
	These differences derive from a number of
	substantive changes in the approach to NFSv4 security presented
	in <xref target="RFC7530"/> and
	<xref target="RFC8881"/> and that appearing in this document.
      </t>
      <t>
        These changes were made in order to improve the security of the
	NFSv4 protocols because it had been concluded that the previous
	treatment of these matters was in error, leading to a situation in 
	which NFSv4's security goals were not met.  As a result, this document
	supersedes the treatment of security in earlier documents,
	now viewed as incorrect.
	However, it will, for the benefit of those familiar with the
	previous treatment of these matters, draw attention to the
	important changes listed here.
      </t>
      <ul>
	<li><t>
	  There is a vastly expanded range of threats being considered
	  as described in <xref target="SECCON-changes-wider"/>
	</t></li>
	<li><t>
	  New facilities provided by RPC on a per-connection basis can be used
	  to deal with security issues, as described in 
	  <xref target="SECCON-changes-conn"/>.  These include the use
	  encryption on a per-connection basis, and the use of
	  peer mutual authentication, to mitigate the security problems
	  that come with the use of AUTH_SYS.
	</t></li>
	<li><t>
	  The handling of identities with superuser privileges is no
	  longer part of NFSv4 semantics, even though many platforms on
	  which NFSv4 servers are implemented continue to depend, for
	  local operation, on the existence of such identities.
	</t><t>
	  NFSv4 servers <bcp14>SHOULD NOT</bcp14> provide for such
	  unrestricted access since doing so would provide a means by
	  which an escalation-of-privilege on a client could be used to
	  compromise a server to which it was connected, affecting
	  all clients of that server.
	</t><t>
	  In connection with the use of "<bcp14>SHOULD NOT</bcp14>" above,
	  and similar uses elsewhere,
	  it is to be understood that valid reasons to do other than
	  recommended are limited to the difficulty of promptly changing
	  existing
	  server implementations and the need to accommodate clients that
	  have become dependent upon the existing handling.  Further,
	  those maintaining or using such implementations need to be aware
	  of the security consequences of such use as well as the fact that
	  clients who become aware of this characteristic may not be inclined
	  to store their data on such a system.
	</t></li>
	<li><t>
	  The appropriate handling of  ACL-based authorization and necessary
	  interactions between ACLs and modes is now specified in this
	  standards-track document rather it being assumed that the behavior
	  of server implementations needs to be accepted and deferred to.
	</t></li>
      </ul>
      <section anchor="SECCON-changes-wider">
        <name>Wider View of Threats</name>
        <t>    
	  Although the absence of a threat analysis in previous treatments
	  makes comparison most difficult, the security-related features
	  described in previous specifications and the associated discussion
	  in their security considerations sections makes it clear that
	  earlier specifications took a quite narrow view of threats to
	  be protected against and placed the burden of providing for secure
	  use on those deploying such systems with very limited guidance as
	  to how such secure use could be provided.
	</t>
	<t>
	  One aspect of that narrow view that merits special attention is
	  the handling of AUTH_SYS, at that time in the clear, with no client
	  peer authentication.
	</t>
        <t>    
	  With regard to specific threats, there is no mention in existing
	  security considerations sections of:
	</t>
	<ul>	
  	  <li><t>
  	    Denial-of-service attacks.
  	  </t></li>
  	  <li><t>
	    Client-impersonation attacks.
  	  </t></li>
  	  <li><t>
	    Server-impersonation attacks.
  	  </t></li>
	</ul>
	<t>
	  The handling of data security in-flight is even more troubling.
	</t>
	<ul>	
  	  <li><t>
	    Although there was considerable work in the protocol to allow
	    use of encryption to be negotiated when using RPCSEC_GSS. The
	    existing security considerations do not mention the potential
	    need for encryption at all.
	  </t><t>
	    It is not clear why this was omitted but it is a pattern that
	    cannot repeated in this document.
	  </t></li>
  	  <li><t>
	    The case of negotiation of integrity services is similar and uses
	    the same negotiation infrastructure.
	  </t><t>
	    In this case, use of integrity is recommended but not to prevent
	    the corruption of user data being read or written.
	  </t><t>
	    The use of integrity services is recommended in connection with
	    issuing SECINFO (and for NFSv4.1, SECINFO_NONAME).  The presence
	    of this recommendation in the associated security considerations
	    sections has the unfortunate effect of suggesting that the
	    protection of user data is of relatively low importance.
	  </t></li>
	</ul>
      </section>
      <section anchor="SECCON-changes-conn">
        <name>Connection-oriented Security Facilities</name>
	<t>
	  Such RPC facilities as RPC-with-TLS provide
	  important ways of providing better security for all the NFSv4
	  minor versions.
	</t>
	<t>
	  In particular:
	</t>
	<ul>
  	  <li><t>
	    The presence of encryption by default deals with security
	    issues regarding data-in-flight, whether RPCSEC_GSS or AUTH_SYS
	    is used for client principal identification.
	  </t></li>
	  <li><t>
	    Peer authentication provided by the server eliminates the
	    possibility of a server-impersonation attack, even when 
	    AUTH_SYS or AUTH_NONE is used to issue requests
	  </t></li>
	  <li><t>
	    When mutual authentication is part of connection establishment,
	    there is a possibility, where an appropriate trust relationship
	    exists, of treating the uids and gids presented in AUTH_SYS
	    requests, as
	    effectively authenticated, based on the authentication of the
	    client peer.
	  </t></li>

	</ul>
      </section>
      <section anchor="SECCON-changes-diverge">
        <name>Necessary Security Changes</name>
        <t>
	  [Consensus Needed (Items #36a, #37a)]: For a variety of reasons,
	  there are many cases in which a change to the security approach
	  has been adopted but for which provisions have been made in order to
	  give
	  implementers time to adapt to the new approach. In
	  such cases the words "<bcp14>SHOULD</bcp14>",
	  "<bcp14>SHOULD NOT</bcp14>", and "<bcp14>RECOMMENDED</bcp14>"
	  are used to
	  introduce the new approach while use of the previous approach
	  is allowed on a temporary basis,
	  by limiting the valid reasons to bypass the
	  recommendation.  Such instances fall into two classes:
	</t>
	<ul>
	  <li><t>
	    [Consensus Needed (Item #36a)]: In adapting to the
	    availability of security services provided by 
	    RPC on a per-connection basis, allowance has been made for
	    implementations
	    for which these new facilities are not available and for
	    which, based on previous standards-track guidance,
	    AUTH_SYS was used, in the clear, without client-peer
	    authentication.
	  </t></li>
	  <li><t>
	    [Consensus Needed (Item #37a)]: In dealing  with
	    server implementations that support both ACLs and the
	    mode attribute, previous specifications have allowed
	    a wide range of
	    possible server behavior in coordinating these attributes.
	    While this document now clearly defines the recommended behavior 
	    in dealing with these issues, allowance has been made to
	    provide time for implementations to conform to the new
	    recommendations.
	  </t></li>
	</ul>
        <t>
	  [Consensus Needed (Items #36a, #37a)]:  The threat analysis
	  within this Security Considerations section will not deal
	  with older servers for which allowance has been made but
	  will explore the consequences of the recommendations made
	  in this document.
	</t>
      </section>
      <section anchor="SECCON-changes-compat">
        <name>Compatibility and Maturity Issues</name>
	<t>
	  [Author Aside]: All unannotated paragraphs within this section
	  are considered part of Consensus Item #38a.
	</t>
	<t>
          Given the need to drastically change the NFSv4 security approach
	  from that specified previously, it is necessary for us to be
	  mindful of:
	</t>
	<ul>
	  <li><t>
	    The difficulty that might be faced in adapting to the newer
	    guidance because the delays involved in designing, developing,
	    and testing new connection-oriented security facilities such as
	    RPC-with-TLS.
	  </t></li>
	  <li><t>
	    The difficulty in discarding or substantially modifying
	    previous existing deployments and practices, developed on the
	    basis of previous normative guidance.
	  </t></li>
	</ul>
	<t>    
          For these reasons, we will not use the term "<bcp14>MUST NOT</bcp14>"
	  in some situations in which the use of that term might have been
	  justified earlier.  In such cases, previous guidance together with
	  the passage of time may have created a situation in which the
	  considerations mentioned above in this section may be valid reasons
	  to defer, for
	  a limited time,
	  correction of the current situation making the term
	  "<bcp14>SHOULD NOT</bcp14>" appropriate, since the difficulties
	  cited would constitute a valid reason to not allow what had been
	  recommended against.
	  
	</t>
	
      </section>
      <section anchor="SECCON-changes-authsys">
        <name>Discussion of AUTH_SYS</name>
	<t>
	  [Author Aside]: All unannotated paragraphs within this section
	  are considered part of Consensus Item #39a.
	</t>
	<t>
	  An important change concerns the treatment of AUTH_SYS which is now
	  divided into two distinct cases given the possible availability of
	  connection-oriented support from RPC.
	</t>
	<t>
	  When such support is not available, AUTH_SYS
	  <bcp14>SHOULD NOT</bcp14> be used, since it makes the following
	  attacks quite easy to execute:
	</t>
	<ul>
	  <li><t>
	    The absence of authentication of the server to the client
	    allow server impersonation in which an imposter server can
	    obtain data to be written by the user and supply corrupted data
	    to read requests.
	  </t></li>
	  <li><t>
	    The absence of authentication of the client user to the server
	    allow client impersonation in which an imposter client can
	    issue requests and have them executed as a user designated by
	    imposter client, vitiating the server's authorization policy.
	  </t><t>
	    With no authentication of the client peer, common approaches,
	    such as using the source IP address can be easily defeated,
	    allowing unauthenticated execution of requests made by the
	    pseudo-clients
	  </t></li>
	  <li><t>
	    The absence of any support to protect data-in-flight when AUTH_SYS
	    is used result in further serious security weaknesses.
	  </t><t>
	  </t><t>
	  </t></li>
	</ul>
	<t>
	  In connection with the use of the term "<bcp14>SHOULD NOT</bcp14>"
	  above, it is understood that the "valid reasons" to use this form
	  of access reflect the Compatibility and Maturity Issue discussed
	  above in <xref target="SECCON-changes-compat"/> and that it is
	  expected that, over time, these will become less applicable. 
	</t>
      </section>
    </section>
  <section anchor="SECCON-scope">
      <name>Security Considerations Scope</name>
      <section anchor="SECCON-scope-levels">
        <name>Discussion of Potential Classification of Environments</name>
	<t>
	  [Author Aside]: All unannotated paragraphs within this section
	  are considered part of Consensus Item #40a.
	</t>
	<t>
	  This document will not consider
	  different security policies for different sorts of environments.
	  This is because,
	</t>
	<ul>
	  <li>
	    Doing so would add considerable complexity to this document.
	  </li>
	  <li>
	    The additional complexity would undercut our main goal here, which
	    is to discuss secure use on the internet, which remain an
	    important NFSv4 goal.
	  </li>
	  <li>
	    The ubiquity of internet access makes it hard to treat corporate
	    networks separately from the internet per se.
	  </li>
	  <li>
	    While small networks might be sufficiently isolated to make
	    it reasonable use NFSv4 without serious attention to
	    security issues, the complexity of characterizing the necessary
	    isolation makes it impractical to deal with such cases in this
	    document.
	  </li>
	</ul>
      </section>
      <section anchor="SECCON-scope-env">
        <name>Discussion of Environments</name>
	<t>
	  [Author Aside]: All unannotated paragraphs within this section
	  are considered part of Consensus Item #40b.
	</t>
	<t>
	  Although the security goal for Nfsv4 has been and remains
	  "secure use on the internet", much use of NFSv4 occurs on more
	  restricted IP corporate networks with NFS access from outside
	  the owning
	  organization prevented by firewalls.
	</t>
	<t>
	  This security considerations section will not deal separately
	  with such environments since the threats that need to be discussed
	  are essentially the same, despite the assumption by many that
	  the restricted network access would eliminate the possibility
	  of attacks originating inside the network by attackers who have
	  some legitimate NFSv4 access within it.
	</t>
	<t>
          In organizations of significant size, this sort of assumption of
	  trusted access is usually not valid and this document will not
	  deal with them explicitly.  In any case, there is little point in
	  doing so, since, if everyone can be trusted, there can be no
	  attackers, rendering threat analysis superfluous.
	</t>
	<t>
	  In corporate networks, as opposed to the Internet, there is good
	  reason to be less concerned about denial-of-service attacks, since
	  there is no tangible benefit to attackers inside the organization,
	  and the anonymity that makes such attacks attractive to outside
	  attackers will not be present.
	</t>
	<t>
	  The above does not mean that NFSv4 use cannot, as a practical matter,
	  be made secure through means outside the scope of this document
	  including strict administrative controls on all software running
	  within it, frequent polygraph tests, and threats of prosecution.
	  However, this document is not prepared to discuss the details of 
	  such policies, their implementation, or legal issues associated
	  with them and treats
	  such matters as out-of-scope.
	</t>
	<t>
	  Nfsv4 can be used in very restrictive IP network environments
	  where outside access is quite restricted and there is sufficient
	  trust to allow, for example, every node to have the same root
	  password. The case of a simple network only accessible by a
	  single user is similar.  In such networks, many thing that this
	  document says "SHOULD NOT" be done are unexceptionable but the
	  responsibility for making that determination is one for those
	  creating such networks to take on. This document will not deal
	  further with NFSv4 use on such networks.
	</t>
      </section>
      <section anchor="SECCON-scope-insecure">
        <name>Insecure Environments</name>
	<t>
	  As noted in <xref target="SECCON-scope-env"/>, NFSv4 is often used
	  in environments of much smaller scope than the internet, with the
	  assumption often being made, that the prevention of NFSv4 access
	  from outside the organization makes the attention to security
	  recommended by this document unnecessary, the possibility of
	  insider attacks being explicitly or implicitly disregarded.
	</t>
	<t>
	  As a result, there will be implementations that do not conform
	  to these recommendations, many of which because the implementations
	  were
	  based on the RFCs <xref target="RFC3530"/>,
	  <xref target="RFC7530"/>,
	  <xref target="RFC5661"/>, or
	  <xref target="RFC8881"/>.   In addition to these cases in which
	  the disregard of the recommendations is
	  considered valid because implementors relied on existing normative
	  guidance, there will be other cases in which implementors choose
	  to ignore these recommendations,
	</t>
	<t>
	  Despite the original focus of <xref target="RFC2119"/> on
	  interoperability, many such implementations will interoperate,
	  albeit without effective security, whether the reasons that
	  the recommendations are not adhered to are considered valid or not.
	</t>
	<t>
	  When such insecure use is mentioned in this Security Considerations
	  section it will only be in explaining the need for the
	  recommendations, by explaining the likely consequences of not
	  following them.  The threat analysis, in
	  <xref target="SECTHREAT"/> and included subsections, will not
	  consider such insecure use and will concern itself with situation
	  in which these recommendations are followed.
	</t>
      </section>
    </section>
    <section anchor="SECCON-major">
      <name>Major New Recommendations</name>
      <section anchor="SECCON-major-data">
        <name>Recommendations Regarding Security of Data in Flight</name>
	<t>
	  [Author Aside]: All unannotated paragraphs within this section
	  are considered part of Consensus Item #41b.
	</t>
	<t>
          It is <bcp14>RECOMMENDED</bcp14> that requesters always
	  issue requests with data
	  security (i.e. with protection from disclosure or modification
	  in flight) whether provided at the RPC request level or on a
	  per-connection basis, irrespective of the responder's requirements.
	</t>
        <t>
          It is <bcp14>RECOMMENDED</bcp14> that implementers
	  provide servers the ability
	  to configure policies in which requests without data security
	  will be rejected as having insufficient security.
        </t>
	<t>
          It is <bcp14>RECOMMENDED</bcp14> that servers use such
	  policies over either their
	  entire local namespace or for all file systems except those
	  clearly designed for the general dissemination of non-sensitive data.
	</t>
	<t>
	  When these recommendations are not followed, data, including data
	  for which disclosure is a severe [problem is exposed to unwanted
	  disclosure or
	  modification in flight.  Depending on the server to be aware
	  of the need for confidentiality or integrity, as expected by
	  previous specifications, has not proved workable, making
	  encryption by default as provided uniformly by RPC
	  (e.g. through RPC-with-TLS)
	  necessary.
	</t>
      </section>

      <section anchor="SECCON-major-cpeer">
        <name>Recommendations Regarding Client Peer Authentication</name>
	<t>
	  [Author Aside]: All unannotated paragraphs within this section
	  are considered part of Consensus Item #41c.
	</t>
        <t>
          It is <bcp14>RECOMMENDED</bcp14> that clients provide
	  authentication material
	  whenever a connection is established with a server capable
	  of using it to provide client peer authentication.
	</t>
        <t>
          It is <bcp14>RECOMMENDED</bcp14> that implementers provide
	  servers the ability to
	  configure policies in which attempts to establish connections
	  without client peer authentication will be rejected.
        </t>
	<t>
          It is <bcp14>RECOMMENDED</bcp14> that servers adopt such
	  policies whenever requests
	  not using RPCSEC_GSS (i.e. AUTH_NONE Or AUTH_SYS) are allowed
	  to be executed.
	</t>
	<t>
	  When these recommendations are not followed, it is possible
	  for connections to be established between servers and client
	  peers that have not been authenticated with the following
	  consequences:
	</t>
	<ul>
	  <li><t>
	    The server will be in the position of executing requests where the
	    identity used in the authorization of operations is not
	    authenticated, including cases
	    in which the identification has been fabricated by an attacker.
	  </t></li>
	  <li><t>
	    When no identification of a specific user is needed or present
	    (i.e AUTH_NO is used) there is no way of verifying that the
	    request was issued by the appropriate client peer.
	  </t></li>
	</ul>
	<t>
	  When the recommendations are followed, use of AUTH_SYS can be
	  valid means of user authentication, so long as due attention is
	  paid to the discussion in <xref target="SECTHREAT-auth-sys"/>.
	  Despite this fact, the description of AUTH_SYS as an
	  "<bcp14>OPTIONAL</bcp14> means of authentication"is no
	  longer appropriate since choosing to use it requires
	  heightened attention to security as discussed later in this
	  document.
	</t>
      </section>
      <section anchor="SECCON-major-super">
        <name>Recommendations Regarding Superuser Semantics</name>
	<t>
	  [Author Aside]: All unannotated paragraphs within this section
	  are considered part of Consensus Item #52c.
	</t>
	<t>
          It is <bcp14>RECOMMENDED</bcp14> that servers adhere to the
	  ACL semantics defined in this document and avoid granting to any
	  remote user, however authenticated, unrestricted access capable
	  of authorizing access where the file/directory ACL would deny it.
	</t>
	<t>
	  Servers are free to conform to this recommendation either by
	  implementing authorization semantics without provisions for
	  superusers or by mapping authenticated users that would have
	  superuser privileges to users with with more limited privileges
	  (e.g. "nobody").
	</t><t>
          It needs to b e understood that the second of these choices is
	  preferable when there are NFsv4-accessible files owned by a
	  special users (e.g. root) whose compromise might be taken advantage
	  of by attackers to enable permanent unauthorized access to
	  a server.
	</t>
      </section>
      <section anchor="SECCON-major-bypass">
        <name>Issues Regarding Valid Reasons to Bypass Recommendations</name>
	<t>
	  [Author Aside]: All unannotated paragraphs within this section
	  are considered part of Consensus Item #41d.
	</t>
        <t>
          Clearly, the maturity and compatibility issues mentioned in
	  <xref target="SECCON-changes-compat"/> are valid reasons to
	  bypass the proposed recommendations requiring pervasive use of
	  encryption, as long as these issues
	  continue to exist.
	</t>
	<t>
	  [Author Aside]: The question the working group
	  needs to address is whether other valid reasons exist.
	</t>
        <t>
	  [Author Aside]: In particular, some members of
	  the group might feel that the performance cost of
	  conection-based encryption
	  constitutes, in itself, a valid reason to ignore the
	  above recommendations.
	</t>
        <t>
          [Author Aside]: I cannot agree and feel that
	  accepting that as a valid reason would undercut Nfsv4 security
	  improvement, and probably would not be acceptable to the
	  security directorate.  However, I do want to work out an a
	  generally acceptable compromise.  I propose something along
	  the following lines:
	</t>
	<t>
          In dealing with recommendations requiring pervasive use of
	  connection-based encryption, it needs to be understood that
	  the connection-based encryption facilities are designed to be
	  compatible with facilities to offload the work of encryption
	  and decryption.  When such facilities are not available, at a
	  reasonable cost, to NFSv4 servers and clients anticipating
	  heavy use of NFSv4, then the lack of such facilities can be
	  considered a valid reason to bypass the above recommendations,
	  as long as that situation continues.
	</t>
      </section>
    </section>
    <section anchor="SECTHREAT">
      <name>Threat Analysis</name>
      <section anchor="SECTHREAT-scope">
	<name>Threat Analysis Scope</name>
	<t>
	  Because of the changes that have been made in NFSv4 security,
	  it needs to be made clear that the primary goal of this
	  threat analysis is to explore the threats that would be faced
	  by implementations that follow the recommendations in this
	  document.
	</t>
	<t>
	  When the possibility is raised of implementations that do not
	  conform to these recommendations, the intention is to explain
	  why these recommendations were made rather that to expand the
	  the scope of the threat analysis to include implementations
	  that bypass/ignore the recommendations.
	</t>
	<t>
	  The typical audience for threat analyses is client and server
	  implementers, to enable implementations to be developed that are
	  resistant to possible threats.  While much of the material in
	  <xref target="SECTHREAT"/> is of that form, it also contains
	  material that relates to threats whose success depends
	  primarily on the ways in which the implementation is deployed,
	  such as the threats discussed in Sections
	  <xref target="SECTHREAT-creds" format="counter"/>,
	  <xref target="SECTHREAT-rogue-server" format="counter"/> and
	  <xref target="SECTHREAT-rogue-client" format="counter"/>.
	  While it is not anticipated
	  that those deploying implementations will be aware of the
	  detail of this threat analysis, it is expected that
	  implementors could use this material to properly set expectations
	  and provide guidance helpful to making deployments secure.
	</t>
      </section>
      <section anchor="SECTHREAT-creds">
	<name>Threats based on Credential Compromise</name>
	<t>
	  In the past, it had been assumed that a user-selected password
	  could serve as a credential, the knowledge of which was
	  adequate to authenticate users and provide a basis for authorization. 
        </t>
        <t>
	  That assumption is no longer valid for a number of reasons:
	</t>
	<ul>
	  <li><t>
	    The inability or unwillingness of users to remember multiple
	    passwords has meant that the single password they will
	    remember controls access to large set of resources, 
	    increasing the value of this knowledge to attackers and
	    the effort that will be expended to obtain it.
	  </t><t>
	    In addition, the common use of a single password for applying
	    to all of a user's data has resulted in a situation in which
	    the client is aware of user passwords (since they are used for
	    client login) that apply to data on many servers.   As will
	    be seen later, this has the effect of changing the
	    considerations appropriate to comparing the security of
	    AUTH_SYS and RPCSEC_GSS.
	  </t></li>
	  <li><t>
	    CPU developments have made exhaustive search possible for
	    larger classes of passwords.
	  </t></li>
	  <li><t>
	    The success of "phishing" attacks taking advantage of user
	    gullibility provides an additional path to credential
	    compromise which need to be addressed in the near-term by
	    those deploying NFSv4, and will eventually need work
	    in the security infrastructure on which NFSv4 is built.
	  </t></li>
	</ul>
	<t>
	  In the near term, there are a number of steps, listed below that
	  those deploying NFSv4 servers can take to mitigate these
	  weaknesses.  These steps are outside the scope of the NFSv4
	  protocols and implementors only role with regard to them is
	  to make it clear that these weaknesses exist and generally
	  require mitigation.
	</t>
	<ul>
	  <li><t>
	    Limitations on password choice to eliminate weak passwords.
	  </t></li>
	  <li><t>
	    Requirements to change passwords periodically.
	  </t></li>
	  <li><t>
	    User education about "phishing" attacks including ways to
	    report them and effective ways of replacing a compromised
	    password.
	  </t></li>
	</ul>
	<t>
	  From a longer-term perspective, it appears that password-based
	  credentials need to be either replaced or supplemented by
	  some form of multi-factor authentication.  Since NFSv4's
	  approach to security relies on RPC, that work would most
	  probably be done within the RPC layer, limiting the work
	  that implementations and the NFSv4 protocols would have to
	  do to adapt to these changes once they are available.  While
	  the precise form of these changes is not predictable, the
	  following points need to be kept in mind.
	</t>
	<ul>
	  <li><t>
	    [Verification Needed (Item #53a)]:
	    For those using RPCSEC_GSS authentication of principals,
	    it appears that RPCSEC_GSS interface is flexible enough
	    that the addition of a second credential element, in the
	    form of a one-time code could be added.
	  </t><t>
	    [Elaboration/Verification Needed (Item #53a)]:
	    Enhancement of Kerberos is one possibility to provide
	    multi-factor authentication.   However, work on this
	    is not far enough along to enable deployment to be
	    discussed now.
	  </t><t>
	    If this approach were taken, rogue servers would still
	    have access to user passwords but their value would be
	    reduced since the second credential element would have a
	    very limited lifetime.
	  </t></li>
	  <li><t>
	    For those using AUTH_SYS to identify principals, the
	    client operating system's authentication of user at login
	    would need to be enhanced to use multi-factor authentication.
	  </t><t>
	    If this were done, the client would retain responsibility
	    for credential verification with the server needing to
	    trust the client, as discussed in
	    <xref target="SECTHREAT-auth-sys"/>.
	  </t><t>
	    Although there is need for protocol standardization to
	    enable this approach to be commonly used, it is not likely to
	    be widely used until some operating system adopts it for
	    user login.  
	  </t></li>
	  <li><t>
	    One important variant of AUTH_SYS use concerns clients
	    used by a single user, when,  as recommended, client-peer
	    authentication is in effect   For such clients, it is possible
	    for the authentication of that specific client peer to
	    effectively become the
	    second factor, in a multi-factor authentication scheme.
	  </t><t>
	    Despite the fact that the the RPC-with-TLS specification
	    <xref target="RFC9289"/>) does not allow
	    TLS to used for user authentication, this arrangement in
	    which the user identity is inferred from the peer authentication,
	    could be used to negate the effects of credential compromise
	    since an attacker would need both the user password, and the
	    physical client to gain access.
	  </t></li>
	</ul>
	  
      </section>
      <section anchor="SECTHREAT-rogue-client">
	<name>Threats Based on Rogue Clients</name>
	<t>
	  When client peers are not authenticated, it is possible
	  to a node on the network to pretend to be a client.   In
	  the past, in which servers only checked the from-IP address
	  for correctness, address spoofing would allow unauthenticated
	  request to be executed, allowing confidential data to be
	  read or modified.
	</t>
	<t>
	  Now that such use of AUTH_SYS is  recommended against, this
	  cannot happen.   The recommended practice is to always authenticate
	  client peers making this sort of imposture easily detectable by
	  the server.
	</t>
	<t>
	  Despite this protection, it is possible that an attacker, through a
	  client vulnerability unrelated to NFSv4, or the installation of
	  malware, could effectively control the client peer and act as
	  imposter client would, effectively undercutting the authentication
	  of the client.   This possibility makes it necessary, as discussed
	  in <xref target="SECTHREAT-auth-sys"/> that those deploying
	  NFSv4 clients using AUTH_SYS takes steps to limit the set of user
	  identifications accepted by a server and to limit the ability of
	  rogue code running on the server to present itself as a client
	  entitled to use AUTH_SYS.
	</t>
      </section>
      <section anchor="SECTHREAT-rogue-server">
	<name>Threats Based on Rogue Servers</name>
	<t>
	  When server peers are not authenticated, it is possible
	  for a node on the network to act as if it were an NFSv4 server,
	  with the ability to save data sent to it and use it or pass
	  it to other, rather than saving it in the file system,
	  as it needs to do..
	</t>
	<t>
	  When current recommendations are adhered to, this is be prevented
	  as follows:
	</t>
	<ul>
	  <li><t>
	    When RPCSEC_GSS is used, the mutual authentication of the server
	    and client principal provides assurance the server is not an
	    imposter.
	  </t></li>
	  <li><t>
	    When AUTH_SYS or AUTH_NONE is used, the mutual authentication
	    of client and server peers provides assurance the server is not an
	    imposter.
	  </t></li>
	</ul>
	<t>
	  Despite this protection, it is possible that an attacker, through a
	  operating system vulnerability unrelated to NFSv4,
	  or the installation of
	  malware, could effectively control the server peer and act as an
	  imposter server would, effectively undercutting the authentication
	  of the server.
	</t>
	<t>
	  The above possibility makes it necessary, that those deploying
	  NFSv4 servers take the following steps, particularly in cases in
	  cases in which the server has access to user credentials,
	  including, but not limited to, cases in which AUTH_SYS is
	  supported
	</t>
	<t>
	  When an NFSv4 is implemented as part of a general-purpose
	  operating system, as it often is, steps need to  be taken to
	  limit the ability of attackers to take advantage of operating
	  system vulnerabilities that might allow the attacker to obtain
	  privileged access and subvert the servers operation, turning it,
	  effectively, into a rogue server.
	</t>
	<t>
	  Such steps include controls on the software installed on the
	  machine acting as the server, and limitation of the network
	  access to potentially dangerous sites.
	</t>
      </section>
      <section anchor="SECTHREAT-data">
	<name>Data Security Threats</name>
	<t>
	  When file data is transferred in the clear, it is exposed to
	  unwanted exposure.   As a result, this document recommends
	  that encryption always be used to transfer NFSv4 requests and
	  responses.
	</t>
	<t>
	  That encryption, whether done on encrypted connections,  or
	  on a per-request basis, using RPCSEC_GSS security services,
	  provides the necessary confidentiality.   In addition, it
	  contributes to security in other ways as well:
	</t>
	<ul>
	  <li><t>
	    The ability of an attacker to plan and execute attacks is
	    enhanced by the monitoring of client-server traffic, even
	    if none of the data intercepted is actually confidentiality.
	  </t><t>
	    An attacker can deduce which users are allowed to read or
	    write a specific file by examining the results of OPEN and
	    ACCESS operations allowing later attacks to impersonate
	    users with the appropriate access.
	  </t></li>
	  <li><t>
	    All the methods of encryption used with NFS4 provide a
	    checksum, to enable the detection of unwanted modifications
	    to data being read or written. 
	  </t></li>
	</ul>
      </section>
      <section anchor="SECTHREAT-auth">
	<name>Authentication-based threats</name>
	<section anchor="SECTHREAT-auth-sys">
	  <name>Attacks based on the use of AUTH_SYS</name>
	  <t>
	    Servers, when they allow access using AUTH_SYS, to a specific
	    client machines using AUTH_SYS are responsible for ensuring
	    that the principal identifications presented to the server
	    can be relied upon.
	  </t>
	  <t>
	    The existence of client-peer authentication as recommended
	    in <xref target="SECCON-changes-authsys"/> means that
	    imposter servers can be detected and not allowed to use
	    AUTH_SYS.  However there are an additional number of issues
	    that need to be addressed to adequately protect against
	    use of AUTH_SYS enabling attacks:
	  </t>
	  <ul>
	    <li><t>
	      The server accepting requests using AUTH_SYS needs to
	      determine that the authenticated client-peer
	      can be trusted to properly authenticate the principals that
	      it identifies in requests.
	    </t><t>
	      The specific standards for trustworthiness are up to the server
	      but they need to take account of the controls in place to
	      prevent malware from pretending to be a client and thus
	      taking advantage of the fact that the request is from the
	      expected client machine.
	    </t><t>
	      This server <bcp14>MUST NOT</bcp14> accept AUTH_SYS requests
	      from unknown clients or from unauthenticated clients. 
	    </t></li>
	    <li><t>
	      [Elaboration Needed (Item #54a)]:
	      The client verification procedure needs to take steps to
	      prevent code on a compromised client to presenting itself as the
	      successor to a legitimate client, taking advantage of
	      the fact that the machine is the same. 
	    </t></li>
	    <li><t>
	      Given the inherent vulnerabilities of client operating
	      systems, it is desirable, to limit the set of users whose
	      identification will be accepted.   The elimination of
	      particular users such as "root' is one long-standing
	      approach to the issue but it probably isn't sufficient
	      in most environments.   More helpful would be the ability
	      to exclude multiple sensitive users or group of users or
	      to limit the user identifications accepted to a user group
	      or a single user.
	    </t></li>
	  </ul>
	  <t>
	    Another important that issue that arises when AUTH_SYS is
	    used concerns the storage of credentials on the clients.
	    While it is theoretically possible for these not to be of
	    use elsewhere, the reluctance/inability of users to
	    remember multiple passwords means that these credentials
	    will be used by many clients and will need to be updated
	    as users are added or deleted or when passwords are changed.
	    The propagation
	    of these credentials and their storage on clients could be
	    the basis for attacks if appropriate step are not taken to
	    secure this data.
	  </t>
	  <t>
	    While it is helpful to store a cryptographic hash of the
	    password rather than the password itself, this does not
	    dispose of the issue, since possession of the hash would
	    greatly simplify an exhaustive search for the password,
	    since the attacker could limit login attempts to guessed
	    password whose hash value matched the value obtained
	    from the files on the client.
	  </t>
	  <t>
	    Although it is true that making clients responsible for
	    authentication of user identities undercuts much of the original
	    motivation for making RPCSEC_GSS <bcp14>REQUIRED</bcp14>
	    to implement, it needs to be understood that the situation
	    today is different from that when this decision was made.
	  </t>
	  <ul>
	    <li><t>
	      It has been recommended that servers not allow unauthenticated
	      clients to issue requests using AUTH_SYS.
	    </t></li>
	    <li><t>
	      The identification of a request as issued by the user with
	      uid zero, no longer provides access without file
	      access authorization.
	    </t></li>
	    <li><t>
	      Given that users are unaware of where their files are
	      located and it is desirable that they are able to
	      remain unaware of this, it is natural that they use
	      the same password to authenticate themselves for local
	      resource use as for use of files located on NFSv4 servers. 
	    </t></li>
	  </ul>
	  <t>
	    Support for AUTH_SYS in NFSv4 was included for a number of
	    reasons which still hold true today, despite the fact that
	    the original mistake, to make no  reference to the security
	    consequences of doing so, is now being corrected. Such
	    provision is necessary for the following reasons, that go
	    beyond the need to temporarily accommodate implementations
	    following the older specifications, for a number of reasons:
	  </t>  
	  <ul>
	    <li><t>
	      When considered, as NFS was to intended to be, as consistent
	      with local access as possible, AUTH_SYS was the natural way
	      of providing authentication, just as it had been done for
	      local files.
	    </t><t>
	      While use of AUTH_SYS exposes user passwords to the client
	      operating system, the fact that user are unable or unwilling
	      to use different passwords for different files in a multi-server
	      namespace means this issue will be present even when AUTH_SYS
	      is not used.
	    </t></li>
	    <li><t>
	      [Elaboration Needed (Item #55a)]:
	      In many important environments including cloud
	      environments, important implementation constraints has made
	      use of Kerberos impractical.
	    </t><t>
  	      [Verification Needed (Item #55a)]:
	      In such environments, client credentials are maintained by the
	      cloud customer while the cloud provider manages network access.
	    </t></li>
	  </ul>
	  
	</section>
	<section anchor="SECTHREAT-auth-mapping">
	  <name>Attacks on Name/Userid Mapping Facilities</name>
	  <t>
	    NFSv4 provides for the identification users and groups
	    in two ways (i.e. by
	    means of strings of  the form name@domain or strings containing
	    numeric uid/gid values) while file systems used on NFSv4 servers
	    typically use 32-bit uids and gids.
	  </t>
	  <t>
	    As a result, NFSv4 server implementations are required to have
	    some means of translating between the name@domain form and the
	    numeric form used internally.  While the specifics of this
	    translation are not specified as part of the NFSv4 protocols,
	    is required for server implementations to work, and, if it not
	    done securely and attackers have the ability to interfere with
	    this translation, it gives them the ability to interfere with
	    authorization as follows:
	  </t>
	  <ul>
  	    <li><t>
	      When authentication occurs using user names, as occurs when
	      RPCSEC_GSS, a mistranslation might allow the numeric value used
	      in authorization to allow access to a file the authenticated
	      user would not be allowed to access.
	    </t></li>
	    <li><t>
	      When any authentication occurs on the client and the uid is
	      presented to the server using AUTH_SYS a mistranslation to
	      the string form could result in confusion and uncertainty
	      about the users allowed to access the file. 
	    </t></li>
	  </ul>
	</section>
    </section>
    <section anchor="SECTHREAT-denial">
      <name>Disruption and Denial-of-Service Attacks</name>
      <section anchor="SECTHREAT-denial-disrupt">
	<name>Attacks Based on the Disruption of Client-Server Shared State</name>
	<t>
	  When data is known to both the client and server, a rogue client
	  can interfere with the correct interaction between client and server,
	  by modifying that shared data, including locking state and
	  session information.
	</t>
	<t>
	  For this reason, it is recommended that client-peer authentication
	  be in effect, because, it it were not, a different client could
	  could easily modify data that the current client depend on, disrupting
	  ones interaction with the server.
	</t>
	<t>
	  It is still possible,  if one's client is somehow compromised,
	  as described in <xref target="SECTHREAT-rogue-client"/>, for
	  various forms of mischief to occur:
	</t>
	<ul>
	  <li><t>
	    Locks required for effective mutual exclusion can be released,
	    causing application failures.
	  </t></li>
	  <li><t>
	    Mandatory share locks can be obtained preventing those with
	    valid access from opening file that they are supposed
	    to have access to.
	  </t></li>
	  <li><t>
	    Session slot sequence numbers may be rendered invalid if requests
	    are issued on existing sessions.   As a result, the client
	    that issued a request would receive unexpected sequence errors. 
	  </t></li>
	</ul>
      </section>
      <section anchor="SECTHREAT-denial-resource">
	<name>Attacks Based on Forcing the Misuse of Server Resources</name>
	<t>
	  It is is also possible for attacks to be mounted, in the absence
	  of the ability to obtain or modify confidential data, with the sole
	  goal of the attack being to make spurious requests, with no
	  expectation that the request will be authorized but with the goal
	  of causing resources that would otherwise be used to service
	  valid requests to be unavailable due to the burden of dealing
	  with numerous invalid requests.
	</t>
	<t>
	  The design of the NFSv4 protocols requires that clients
	  establishing new connections make initial requests which
	  establishes a shared context referred to by subsequent requests
	  which might request substantive actions (e.g. client and session
	  ids).  This structure helps mitigate the effect of such
	  denial-of-service attacks as described below.
	</t> 
	<ul>
  	  <li><t>
	    The server can limit the resources devoted to connections
	    not yet fully identified without unduly restricted connections
	    which have identified themselves.
	  </t></li>
	  <li><t>
	    The recommendation that client peers authenticate themselves,
	    allows unknown clients to be dispensed with at an early stage
	    negating their ability to make requests which could require
	    file system action to obtain information needed to make
	    authorization decisions (e.g. ACLs or other
	    authorization-related) file attributes.
	  </t></li>
	</ul>
     </section>
    </section>
    </section>
  </section>
  <section anchor="IANA">
    <name>IANA Considerations</name>
    <t>
      [Author Aside]: All unannotated paragraphs in this section are
      to be considered part of Consensus Item #32c.
    </t>
    <t>
      Because of the shift from implementing security-related services
      only in connection with RPCSEC_GSS to one in which connection-oriented
      security has a prominent role, a number if new values need to be
      assigned.
    </t>
    <t>
      These include new authstat values to guide selection of a
      connection types acceptable to both client and server, presented in
      <xref target="IANA-authstat"/> and new pseudo-flavors to be used
      in the process of security negotiation, presented in
      <xref target="IANA-flavors"/>.
    </t>
    <section anchor="IANA-authstat">
      <name>New Authstat Values</name>
      <t>
	[Author Aside]: All unannotated paragraphs in this section are
	to be considered part of Consensus Item #32d.
      </t>
      <t>
	The following new authstat values are necessary to enable a
	server to indicate that the server's policy does not allows
	requests to be made on the current connection because of
	security issues associated with connection type used.  In the
	event they are received, the client needs to establish a new
	connection.
      </t>
      <ul>
	<li><t>
	  The value XP_CRYPT indicates that the server will not support
	  access using unencrypted connections while the current connection
	  is not encrypted.
	</t></li>
	<li><t>
	  The value XP_CPAUTH indicates that the server will not support
	  access using connections for which the client peer has not
	  authenticated itself as part of connection while the current
	  connection has not been set up in that way.
	</t></li>
      </ul>
    </section>
    <section anchor="IANA-flavors">
      <name>New Authentication Pseudo-Flavors</name>
      <t>
	[Author Aside]: All unannotated paragraphs in this section are
	to be considered part of Consensus Item #32e.
      </t>
      <t>
	The new pseudo-flavors described in this section are to be made
	available to allow their return as part of the response to the
	SECINFO and SECINFO_NONAME operations.  How these operations
	are to used to negotiate the use of appropriate auth flavors
	and associated security-relevant connection characteristics
	is discussed in <xref target="NEGO"/>.
      </t>
      <t>
	The following pseodo-flavors are to be defined:
      </t>
      <ul>
	<li><t>
	  PFL_CRYPT is returned to indicate that subsequent secinfo
	  entries are to considered
	  limited to use on connections for which transport-level
	  encryption is provided.
	</t></li>
	<li><t>
	  PFL_CRYPTMPA is returned to indicate that subsequent secinfo
	  entries are to be considered
	  limited to use on connections on which mutual peer authentication
	  has been provided at connection setup.
	</t></li>
	<li><t>
	  PFL_ANY is returned to indicate that subsequent secinfo entries
	  are not to be considered limited to any particular type of
	  connection.
	</t></li>
      </ul>
    </section>
  </section>
  </middle>
  <back>
  <references>
    <name>References</name>
    <references>
      <name>Normative References</name>
       <?rfc include="reference.RFC.2119.xml"?>
       <?rfc include="reference.RFC.8174.xml"?>
       <?rfc include="reference.RFC.7530.xml"?>
       <?rfc include="reference.RFC.8178.xml"?>
       <?rfc include="reference.RFC.8881.xml"?>
       <?rfc include="reference.RFC.7862.xml"?>
       <?rfc include="reference.RFC.9289.xml"?>
       <reference anchor="nist-209">
	 <front>
	   <title>
	     SP 800-209 Security Guidelines for Storage Infrastructure
	   </title>
	   <author asciiSurname="Chandramouli"
		   asciiFullname="Ramaswamy Chandramouli">
	     <organization>NIST</organization>
	   </author>
	 </front>
       </reference>
    </references>
    <references>
      <name>Informative References</name>
       <?rfc include="reference.RFC.8257.xml"?>
       <?rfc include="reference.RFC.3010.xml"?>
       <?rfc include="reference.RFC.3530.xml"?>
       <?rfc include="reference.RFC.5661.xml"?>
       <?rfc include="reference.RFC.1813.xml"?>
       <?rfc include="reference.I-D.ietf-nfsv4-internationalization.xml"?>
       <?rfc include="reference.I-D.dnoveck-nfsv4-acls.xml"?>
        <reference anchor="errata" target="https://www.ietf.org/about/groups/iesg/statements/processing-rfc-errata/" quoteTitle="true" derivedAnchor="51">
          <front>
            <title>IESG Processing of RFC Errata for the IETF Stream</title>
            <author>
              <organization showOnFrontPage="true">IESG</organization>
            </author>
            <date month="July" year="2008"/>
          </front>
        </reference>
    </references>
  </references>
  <section anchor="CHG">
    <name>Changes Being Made</name>

    <t>
      This appendix summarizes the significant changes between the
      treatment
      of security in previous minor version specification documents
      (i.e. RFCs 3630, 7530, 5661 and 8881) and the new treatment that is
      intended to apply to NFSv4 as a whole.  This includes changes made in
      both this document and in the companion document relaing to ACLs
      <xref target="I-D.dnoveck-nfsv4-acls"/>.
    </t>
    <t>
      This revieww is expected to be helpful to implementers familiar
      with previous
      specifications but also has an important role in guiding the search
      for working
      group consensus as to these changes and in identifying
      potential compatibility issues.
    </t>
    <section anchor="CHG-motive">
      <name>Motivating Security Changes</name>
      <section anchor="CHG-motive-fund">
      <name>Fundamental Security Changes</name>

      <t>
        A number of changes reflect the basic motivation for a new
	treatment of NFSv4 security.  These include the ability to
	obtain privacy and integrity services from RPC on a per-connection
	basis
	rather than as a service ancillary to a specific auth
	flavor.
      </t>
      <t>
	This need to properly accomodate this new ficus motivated a
	major reorganization of the treatment of
	security together with further emphasis on the security of
	data in flight, described in detail in <xref target="DATA"/>.
	In addition, the security negotiation framework
	for NFSv4 has been enhanced to support the
	combined negotiation of authentication-related services and
	connection characteristics, as described in <xref target="NEGO"/>.
      </t>
      <t>
	Despite these major changes, there are not expected to be troublesome
	compatibility issues between peers supporting provision of
	security services on a per-connection basis and those without
	such support.  Clients who are adapted to the new security
	facilities
	can use them when the server supports them, but will sometimes
	choose
	to use the older facilities when interacting with older servers.
	Servers who support the new facilities have the option of rejecting
	client connections from older clients but are encouraged to adopt
	policies rejecting such connections.   Over time, it is expected
	that use of the older facilities will become less common as the newer
	facilities become more commonly implemented and the importance of
	security becomes more generally recognized 
      </t>
      <t>
	Another such change was in the treatment of AUTH_SYS, previously
	described, inaccurately, as an "<bcp14>OPTIONAL</bcp14> means of
	authentication"
	with the unfortunate use of the RFC2119 keyword obscuring the negative
	consequences of the typical use of AUTH_SYS (in the clear,
	without client-peer authentication) for security by enabling the
	execution of unauthenticated requests.
      </t>
      <t>
        The new treatment avoids the inappropriate use of term
	"authentication" for all activities triggered by the use of RPC
	auth flavors and clearly distinguishes those flavors
	providing authentication from those providing identification only
	or neither identification nor authentication.  For details, see
	<xref target="IDENT"/>.
      </t>
      <t>
	As part of the necessary shift from a narrative focused on
	justifying security choices already made to evaluating the
	adequacy of existing security facilities, there has been a need
	to discuss NFSv4 security gaps, which might be addressed later.
	See <xref target="FUTURE-base"/> for a discussion of possible
	security-related extensions.
      </t>
      <t>
	There are twelve consensus items (described in
	<xref target="ISSUES"/>) that are involved in effecting
	this class of changes.  Although it is generally understood that
	the working group needs to take advantage of RPC-with-TLS, change
	how use of AUTH_SYS is presented, and include a credible threat
	analysis, there needs to be further discussion of these items as
	working group members are likely to disagree about the relative
	importance of:
      </t>
      <ul>
	<li><t>
	  accommodating implementations based on previous specifications.
	</t></li>
	<li><t>
	  providing a description of the expected path toward secure
	  implementations
	</t></li>
	<li><t>
	  maintaining and improving implementation performance
	</t></li>
      </ul>
      <t>
	For each of the following items, there may need to be extensive
	discussion to arrive at a consensus text.
      </t>
      <ul>
	<li><t>
	  Consensus Item #32 concerns extension of the process of SECINFO
	  negotiation to accommodate the use of facilities such as
	  rpc-with-tls, in addition to the
	  current approach which directs only the choice of a suitable
	  auth flavor.
	</t><t>
	  In the current document, pseudoflavors are added to allow the
	  specification of connection characteristics, lthough it would
	  be possible to avoid use and select connection characteristics
	  by a process of trial and error.
	</t></li>
	<li><t>
	  Consensus Item #52 concerns the handlinng of superuser semantics
	  within NFSv4.
        </t><t>
	  There is a long tradition, within NFS, of treating superusr
	  semantic, involving the elimination of file authorization checks,
	  as part of protocol semantics.   The security problems that this
	  creates have been dealt with via "root-squashing", outside the
	  protocol specification.  Given that a threat analysis would
	  essentially make such suppression of superuser semantics
	  unavoidable, the current document deals with such semantics
	  outside
	  of the NFSv4 protocol.
	</t></li>
	<li><t>
	  Consensus Item #36 concerns how to deal with the troublesome
	  legacy of use of AUTH_SYS without client authentication and
	  the common transmission of requests and responses without encryption.
	</t><t>
	  The specification now makes it clear that this has the potential
	  to cause harm, while needing to deal ith the fact that it is
	  a long time before this could be forbidden or recommmended against
	  without allowances being made for current implementations.
	  The ways that this issue needs to be dealt with require
	  further discussion.
	</t></li>
	<li><t>
	  Consensus Item #38 concerns temporary accommodations to deal
	  with previous implementations which are unsafe.
	</t><t>
	  This is a consequence of existing implemenations based on current
	  RFCs.  The wording will require extensive discussion.
	</t></li>
	<li><t>
	  Consensus Item #39 defines the new safer approach to AUTH_SYS.
	</t><t>
	  There needs to be discussion about how this safety should be
	  characterized, given that you are trusting the client OS.
	</t></li>
	<li><t>
	  Consensus Item #40 concerns the scope for the threat analysis in
	  the Security Considerations section.
	</t><t>
	  Will need to reach a consensus on this as there appears to be
	  no way
	  we can make allowances in which physical isolation makes a
	  significant difference, since this ssentially ignores insider
	  threats.
	</t></li>
	<li><t>
	  Consensus Item #41 discusses the major new security recommendations
	  regarding protection of data in flight and client peer authentication.
	  Also, covers the circumstances under which such recommendations
	  can be bypassed.
	</t><t>
	  Will have to address concerns about performance effects.
	</t></li>
	<li><t>
	  Consensus Item #47 concerns dubious paragraph regarding AUTH_NONE
	  in SECINFO response which should be deleted if there
	  are no compatibility issues that make that impossible.
	</t><t>
	  Will have to ascertain whether this is in fact supported by any
	  server or relied on by any client.
	</t></li>
	<li><t>
	  Consensus Item #35 discusses possible work on future security needs.
	</t><t>
	  Need to discuss whether there is too much or too little
	  forward-looking material.
	</t></li>
	<li><t>
	  Consensus Item #53 concerns the possible use of multi-factor
	  authentication.
	</t><t>
	</t></li>
	<li><t>
	  Consensus Item #54 discusses prevention of code on a compromised
	  client from hijacking the client machine's peer authentication.
	</t><t>
          This relates to getting clarity about the safety of the client
	  peer authentication available in rpc-with-tls.
	</t></li>
	<li><t>
	  Consensus Item #55 discusses issues related to potential use
	  of Kerberos in cloud environments.
	</t><t>
          We will have to be sure we have a strog case here, since ther
	  may be a feeling within the IESG that AUTH_SYS is per se
	  unacceprable.
	</t></li>
      </ul>
    </section>
    <section anchor="CHG-motive-acl">
      <name>ACL-Related Changes</name>
      <t>
	In addition to the above there has been a respecfication of
	ACL-related features appearing in the companion document
	<xref target="I-D.dnoveck-nfsv4-acls"/> and summarized in
	<xref target="ACL-approach"/>.
      </t>
      <t>
        Relevant consensus items relating to this respecfication are
        discussed in the companion docuent.
      </t>
    </section>
  </section>
    <section anchor="CHG-nclar">
      <name>Need for Clarifying Changes</name>
      <t>
	The need to make the major changes discussed in
	<xref target="CHG-motive"/> has meant that much text dealing
	with security has needed to be significantly revised or
	rewritten.  As a result of that process, many issues involving
	unclear, inconsistent, or otherwise inappropriate text were
	uncovered and now need to be dealt with.
      </t>

      <t>
	While the author believes that changes in this situation
	are necessary, the fact
	that we are changing a document adopted by consensus requires
	the working group to be clear about the acceptability of the
	changes.   This applies to both the troublesome issues
	discussed in <xref target="UINTRO-needwork"/> and to the other
	changes included below.
      </t>
      <t>
	The primary source of these not-clearly specified elements is the
	disparate goals of many participants in the specification process:
      </t>
      <ul>
	<li><t>
	  For many participants, the ACL definition needed to include a
          large part of Windows-oriented semantics, including elements
          clearly distinct from the Unix semantics supported by earlier versions
          of NFS.
        </t></li>
	<li><t>
	  For other participants, such semantic extensions were of little
	  interest.
	</t></li>
      </ul>
      <t>
	While the author believes such changes are necessary, the fact
	that we are changing a document adopted by consensus requires
	the working group to be clear about the acceptability of the
	changes.   This applies to both the troublesome issues
	discussed in <xref target="UINTRO-needwork"/> and to the other
	changes included below.
      </t>
      <t>
	Because of the need for  re-organization of subjects relating to
	authorization, the ordering of the
	list  follows the text of the current version which may differ
	considerably from that in earlier versions of the I-D.
      </t>
      <t>
	The subjects related to authorization needed to be reorganized
	because of the following complexities:
      </t>
      <ul>
	<li><t>
	  There are three kinds of authorization to deal with.
	</t></li>
	<li><t>
	  The most important kind of authorization, file access
	  authorization, is controlled by mode attributes and a set of
	  ACL-related
	  attributes, creating multiple authorization models and a
	  need to coordinate them.
	</t></li>
	<li><t>
	  ACLs, besides their prominent role with regard to file access
	  authorization, provide control of alarm and audit facilities.
	</t></li>
      </ul>
      <t>
	 As a result, these matters are dealt with in the eight top-level
	 sections within this document and the associated ACL document
	 from <xref target="ATTR" format="counter"/> through
	 <xref target="OTHACL" format="counter"/>.  Of these, three
	 sections, Sections <xref target="ACL" format="counter"/>,
	 <xref target="AUTHCOMM" format="counter"/> and
	 <xref target="OTHACL" format="counter"/>, have become
	 brief overiews wjich introduce matters dealt with in more
	 detail in the companion ACL document
	 <xref target="I-D.dnoveck-nfsv4-acls"/>. 
      </t>
      <ul>
	<li><t>
	  <xref target="ATTR"/>,a new top-level section, describes 
	  all the authorization-related attributes. Although this
	  section cover all of the attributes, details relating to
	  the ACL-related ones appear in the companion ACL document.
	</t></li>
	<li><t>
	  <xref target="ACL"/>, a new top-level section, provide
	  an introduction to 
	  the structure of ACLs with the corresponding detail appearing
	  in the companion ACL document
	  <xref target="I-D.dnoveck-nfsv4-acls"/>. 
	  Later their uses are described later
	  sections <xref target="AUTHFA" format="counter"/> through
	  <xref target="AUTHCOMB" format="counter"/> and in
	  <xref target="OTHACL"/> of which the last two serve as
	  introductions to matters dealt with in the companion ACL
	  document.
	</t></li>
	<li><t>
	  In <xref target="AUTHG"/>, there is a discussion of authorization 
	  in general.   This includes a discussion of user-based
	  file authentication, NFSv4's approach to mandatory access control,
	  and a discussion of locking state
	  authorization, each of which is described in later top-level
	  sections. 
	</t></li>
	<li><t>
	  File access authorization is described primarily in
	  <xref target="AUTHFA"/>.  Because this authorization can be
	  controlled by either the mode attribute or various ACL-related
	  attributes, there is an introduction to these authorization-
	  determining attributes in <xref target="AUTHFA-attr"/>.
	</t><t>
	  Because file access authorization can be controlled by the
	  posix-related authorization attributed decribed in
	  <xref target="ATTR-posix"/> and by ACL-related
	  attributes described in <xref target="ATTR-aclr"/>, 
	  there is an introduction to how these relate in
	  <xref target="AUTHFA-two"/>
	  followed by discussion of the semantics of the two kinds of
	  supported ACLs in <xref target="AUTHFA-acl"/>.
	</t><t>
	  Issues related to the existence of two separate file access are
	  dealt with in Sections
	  <xref target="AUTHCOMM" format="counter"/>, dealing with the
	  similarities between these two, and
	  <xref target="AUTHCOMB" format="counter"/> dealing with their
	  co-existence and potential conflict.
	</t></li>
	<li><t>
	  Sections <xref target="AUTHL" format="counter"/> through 
	  <xref target="OTHACL" format="counter"/> deal with, labelled
	  NFS authorization, state modification authorization, and the
	  uses of ACLs outside authorization.
	</t></li>
      </ul>
      <t>
	Beyond the reorganization described above, there are numerous
	matters to be dealt with, reflecting the previous inability to
	clearly specify two sets of authorization behaviors and their
	potential interactions.
      </t>
      <ul>
	<li><t>
	  Also in <xref target="AUTHFA-two"/>,
	  there is added clarity in the discussion of support for multiple
	  authorization approaches by
	  eliminating use of the subjective term "reasonable semantics".
	</t><t>
	  In connection with this clarification, we have switched from
	  describing the needed co-ordination between modes and acls
	  as "goals" to describing them as "requirements" to give
	  clients some basis for expecting interoperability in handling
	  these issues.
         </t><t>
	  As a result of this shift to a prescriptive framework applying
	  to all minor versions it becomes possible to treat all minor
	  versions together.  In existing RFCs and some earlier versions
	  of this document, it had
	  been assumed that NFSv4.0 was free to ignore the relevant
	  prescriptions first put forth in RFC 5661 and only needed to
	  address the "goals" for this co-ordination.
	</t></li>
      </ul>

    </section>

    <section anchor="CHG-clarfix">
      <name>Addressing the Need for Clarifying Changes</name>
      <t>
	Unlike the issues discussed in <xref target="CHG-motive"/>, for
	which the path to make the necessary changes is laid out
	in that same section, the changes discussed in
	<xref target="CHG-nclar"/>, are discussed here, because resolving
	them is a more involved matter.
      </t>
      <t>
	The difficulty derives principally from the fact that there
	are existing clients and server with very different approaches
	to these matters, making it difficult or impossible to reach a
	consensus that will make some existing clients non-compliant.
      </t>
      <t>
	In such a situation, we need to allow a set of possibitlities,
	as has been done for internationalization of file names
	in <xref target="RFC7530"/>
	for NFSv4.0 and
	in <xref target="I-D.ietf-nfsv4-internationalization"/>,
	for all minor versions.
      </t>
      <t>
	As in the case of the internationalization of file names,
	we will have to
	accommodate a range of possible server implementations, but the task
	will, in this case, involve a lot more work.  To see why, we
	will first explore the situation for internationalization of
	file names and
	later see how the situation for these issues poses greater
	difficulties and how they might be addressed.  Some of these
	dificulties match other internationalization issues, such as
	the handling of internationalized domain names and the proper
	treatment of case-insensitive handling of file names that dealt
	with incorrectly or not at all in <xref target="RFC7530"/>.
      </t>
      <ul>
	<li><t>
	  The treatment of internationalization of file names in
	  <xref target="RFC7530"/>
	  and <xref target="RFC5661"/> was so divorced from the needs
	  of implementations that it was necessary to be ignore it.
	</t><t>
	  On the other hand, the treatment of internationalization of
	  file names in
	  the obsoleted document <xref target="RFC3010"/> was available
	  as a base and had been implemented by many clients and servers.
	</t></li>
	<li><t>
	  The vast majority of clients and servers implemented the same
	  approach to internationalization, even  though it was not
	  limited to the use of UTF-8.
	</t><t>
	  Despite the general aversion to this approach within the IESG, it
	  was accepted, most likely because we were describing NFSv4
	  internationalization on "as-implemented" basis.
	</t></li>
	<li><t>
	  Overall, we wound up allowing a total of three sorts of
	  server behaviors, two of which were UTF-8-aware.
	</t><t>
	  One UTF-8-aware option that had been implemented, simply
	  considred canonically equivalent names as deignating the same
	  file with changing the name to a different canonically
	  equivalent name.  Although this approach diverged from
	  IESG expectations regarding normalization, it was accepted.
	</t><t>
	  Another UTF-8-aware option was allowed, despite the absence of any
	  implementations.  It allowed servers to normalize file names
	  while forbidding them from rejecting unormalized names. This was
	  allowed because it would cause no difficulties for clients and
	  because forbidding it might have caused problems for IESG
	  acceptance.
	</t></li>
	<li><t>
	  We were able, where necessary, to give the client the ability
	  to detrmine which form of internationalization supported
	  provided by the server for any particular file system, using
	  an <bcp14>OPTIONAL</bcp14> attribute made available in NFSv4.1.
	</t></li>
      </ul>
      <t>
	The situation with regard to the clarifying changes needed in this
	document is different for the reasons listed below. 
      </t>
      <ul>
	<li><t>
	  Rather than three valid choices for acceptable server behavior,
	  with authorization we have a vast number.
	</t><t>
	  Given that there are nine ACE mask bits, each of whick might not
	  be supported, there are at least 512 possible valid behaviors,
	  even if none of the dubious instances of <bcp14>SHOULD</bcp14>
	  creates additional valid behavioral patterns.
	</t><t>
          Added to that are multiple (at least two) ways of mapping ACLs
	  to modes and at leat three different behaviors in  mdifying
	  ACLs to reflect changes in mode.
	</t><t>
	  As a result,  existing RFCs allow at least three thousand
	  different server behaviors.
	</t></li>
	<li><t>
	  There is little information available about the particular
	  behaviors manifested by existing server-fs combinations.
	</t><t>
	  It may be difficult to get this informarion because the
	  implementations were done by people no longer participating
	  in the working or who were never involved in the
	  working group
	</t></li>
	<li><t>
	  There are no existing attributes that might be used to
	  communicates server/fs choices to the client.
	</t></li>
      </ul>
      <t>
	This creates a difficult situation.  To fully resolve it will
	require substantial work as follows:
      </t>
      <ul>
	<li><t>
	  Determining whether each of the dubious instances of
	  "<bcp14>SHOULD</bcp14>" is in fact relied on by existing servers
	  or might be needed by future servers.
	</t></li>
	<li><t>
	  Determining which ACE mask bits are supported by all existing
	  servers or not supported by any existing server to further limit
	  the set of <bcp14>OPTIONAL</bcp14> features that clients
	  need to be made aware of.
	</t><t>
	  There might also be cases where some set of mask bits are
	  are always either supported or unsupported together.
	</t></li>
	<li><t>
	  Determining the set of mappings from acls to modes that are
	  actually and making each such <bcp14>OPTIONAL</bcp14> as
	  opposed to the current situation in which an "intentional"
	  "<bcp14>SHOULD</bcp14>" is used despite the mismatch
	  between this use and <xref target="RFC2119"/>.
	</t></li>
	<li><t>
	  Making a similar determination of the actions actually  applied
	  to acl when the mode is changed.
	</t></li>
      </ul>
      <t>
	Once we have the above information, it will be clear how we
	could create adress these issues inn either of the ways
	discused below:
      </t>
      <ul>
	<li><t>
	  Have a way of determining whether support of NFSv4 ACL
	  semaniics or UNIX ACL semantics is provided by any
	  particular file system, such as that discussed in
	  consensus item #61.
	</t><t>
	  This approach wiuld address the motive for the current
	  under-specfication but would not address possible
	  negative coonsequences arising from that under-specification.
	</t><t>
	  A further difficulty with it is that it does not address the
	  possibility of hybrids of the two models.
	</t></li>
	<li><t>
          providing an appropriate extension as described in
	  <xref target="ACL-approach"/> to provide clients with an
	  adequate description of expected server behavior.  This
	  document will be limited to providing client implementation
	  guidance about dealing with the uncertinty in cases in which
	  new attributes is not available.  The situation will be similar
	  to that described in Section 15 of
          <xref target="I-D.ietf-nfsv4-internationalization"/>.
	</t></li>
      </ul>
    </section>
  </section>
  <section anchor="ISSUES">
    <name>Issues for which Consensus Needs to be Ascertained</name>
    <t>
      This section, togther with a corresponding Appendix in the ACL
      document, helps to keep track of specific changes which the
      author has made or intends to make to deal with issues found
      in RFCs 7530 and 8881.
    </t>
    <t>
      The changes listed exclude those that only apply to the ACL document
      but does include cases in which there might need co-ordination
      between the two documents.  The changes listed here exclude those which
      are clearly editorial but include some that the author believes are
      editorial but for which the issues are sufficiently complicated that
      working group consensus on the issue is probably necessary.
    </t>
    <t>
      These changes are presented in the table below, organized into a set
      of "Consensus Items" identified by the numeric code appearing  in
      annotations in the proposed document text.  For each such item,
      a type
      code is assigned with separate sets of code define for pending items
      and for those which are no longer pending.
    </t>
    <t>
      This document and the companion ACL document use a shared set of
      nmeric ids to identify Cinsensus Item,  Some of these were
      originally defined in this document and subsequently moved while
      others were created as part of the ACL document.  In order to
      maintain a common list without requiring excessive document
      cooridnation the follow practices and consquences should be noted.
    </t>
    <ul>
      <li><t>
	Before the documents were split the numbers from one to sixty-two were
	assigned to Consensus Items while some ofthese were moved to the
	ACL document.
      </t><t>
        Item numbers in this range might appear in either document, although
        each number will appear in only a single document.
      </t></li>
      <li><t>
	New issues will receive a number based on the document in which the
	issue appears:
      </t><t>
      Item numbers sixty-two through ninety-nine will be assigned to
      issues in this
        document while those above one-hundred will be used in the ACL
	document.
      </t></li>
      <li><t>
	As part of the documents being  split some items that apply to both
	were
	split, with the portion appearing in this document retaining the
	old number a new number (over one-hundred)
	being assigned to the ACL-related portion.
      </t><t>
      In such cases, the related document items in the two document will
      refer to one anothe.
      </t></li>
    </ul>
    <t>
      The following type codes are defined for pending consensus items:
    </t>    
    <ul>
      <li><t>
	"NM" denotes a change which is new material that is not purely
	editorial and thus requires Working Group consensus for
	eventual publication.
      </t></li>
      <li><t>
	"BE" denotes a change which the author believes is editorial but
	for which the change is sufficiently complex that the judgment
	is best
	confirmed by the Working Group.
      </t></li>
      <li><t>
	"BC" denotes a change which is a substantive change that the author
	believes is correct.  This does not exclude the possibility of
	compatibility issues becoming an issue but is used to indicate that
	the author believes any such issues are unlikely to prevent
	its eventual acceptance.
      </t></li>
      <li><t>
	"CI" denotes a change for which the potential for
	compatibility issues
	is a major concern with the expected result that working group
	discussion of change will focus on clarifying our knowledge of how
	existing clients and server deal with the issue and how they might
	be affected by the change or the change modified to
	accommodate them.
      </t></li>
      <li><t>
	"NS" denotes a change which represents the author's best effort to
	resolve a difficulty but for which the author is not yet
	confident that it will be adopted in its present form,
	principally because of the possibility of
	troublesome compatibility issues.
      </t></li>
      <li><t>
	"NE" denotes change based on an existing issue in
	the spec
	but for which the replacement text is incomplete and needs further
	elaboration.
      </t></li>
      <li><t>
	"WI" denotes a potential change based on an existing issue in
	the spec
	but for which replacement text is not yet available because
	further working group input is necessary before drafting.
	It is expected that replacement text
	will be available in a later draft once that discussion is done. 
      </t></li>
      <li><t>
	"LD" denotes a potential change based on an existing issue in the
	spec but for which replacement text is not yet available due to
	the press of time.   It is expected that replacement text
	will be available in a later draft.
      </t></li>
      <li><t>
	"EV" denote a potential change which is tentative or incomplete
	because further details need to be provide or because the author
	is unsure that he has a correct explanation of the issue.
	It is expected that replacement text
	will be available in a later draft.
      </t></li>
    </ul>
    <t>
      The following codes are defined for consensus items which are no
      longer pending.
    </t>
    <ul>
      <li><t>
	"RT" designates a former item which has been retired, because it
	has been merged with another one or otherwise organized out of
	existence. 
      </t><t>
        Such items no longer are referred to the document source although
        the item id is never reassigned.  They are no longer counted
	among the set of total items.
      </t></li>
      <li><t>
	"CA" designates a former item for which consensus has been
	achieved in the judgment of the author, although not
	by any official process. 
      </t><t>
        Items reaching this state are effected in the document source
        including the deletion of annotations and the elimination of
	obsoleted previous treatments.
      </t><t>
        Items in this state are still counted among the total of item
        but are no longer considered pending        	
      </t></li>
      <li><t>
	"CV" designates a former item for which consensus has been
	achieved and officially verified. 
      </t><t>
        Even though the author is a Working Group co-chair,it is
        probably best
	if he is not involved in this process and intends to leave it
	to the
	other co-chairs, the Document Shepherd and the Area Director. 
      </t><t>
        Items in this state are not counted among the item totals.
        They may be kept in the table but only to indicate that the item id
	is still reserved.
      </t></li>
      <li><t>
	"DR" designates a former item which has been dropped, because it
	appears that working group acceptance of it, even with some
	modification, is unlikely.
      </t><t>
        Such items no longer are referred to the document source although
        the item id is never reassigned.  They are no longer counted
	among the set of total items.	
      </t></li>
    </ul>
    <t>
      When asterisk is appended to a state of "NM", "BC" or "BE" it
      that there has been adequate working group discussion leading
      one to reasonably expect it will be adopted, without major change,
      in a subsequent document revision.
    </t>
    <t>
      Such general acceptance is not equivalent to a formal
      working group consensus and it not expected to result in major
      changes to the draft document,
    </t>
    <t>
      On the other hand, once there is a working group consensus with
      regard to a particular issue, the document will be modified to remove
      associated annotations, with the previously conditional text
      appearing just as other document text does.  The issue will remain
      in this table as a non-pending item. It will be mentioned in
      Appendices <xref target="CHG-motive" format="counter"/> or
      <xref target="CHG-nclar" format="counter"/> to summarize the
      changes that have been made.
    </t>
    <t>
      It is to be expected that these designations will change
      as discussion proceeds and new document versions are published.
      It is hoped that most such shifts will be upward in the above list or
      result in the deletion of a pending item, by reaching a consensus to
      accept or reject it.  This would enable, once all items are dealt with,
      an eventual request for publication as an RFC, with this appendix
      having been deleted.
    </t>
      <t>
	[Editor Aside]: The following Consensus Items have been moved, in
        their entirety, to the new acl spec: #3, #4, #5, #8, #9, #7, #10, 
	#11, #12, #13, #14, #15, #16, #17, #26, #27, #28, #29, #30, #31,
	#50, #51, #6
	1.  They have retained their numeric existing numeric
	ids.
      </t>
      <t>
	[Editor Aside]: The following Consensus Items had to be split between
	this document and the new acl spec, with a new id assiged for the
	portion in the acl spec: #6, #25, #56, #58.  The new ids
	assigned are in the range between #62 and #65.
      </t>
      <t>
	[Editor aside]: New items added to this spec after the split will
	be assigned id's between #66 and #99.  New item s added to the ACL
	spec will be assigned ids in the range btween #100 and #199.
      </t>
    <table>
      <thead>
	<tr>
	  <th>#</th>
	  <th>Type</th>
	  <th>...References...</th>
	  <th>Substance</th>
	</tr>
      </thead>
      <tbody>
	<tr> 
          <td>1</td>
	  <td>CA</td>
	  <td>
	    <t>
	      Assumed OK.
	    </t>
	  </td>

	  <td>
	    <t>
              New approach distinguishing authetication and identification.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>2</td>
	  <td>CA</td>
	  <td>
	    <t>
	      Assumed OK.
	    </t>
	  </td>

	  <td>
	    <t>
              Outline of new negotiation framework.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>6</td>
	  <td>CI</td>
	  <td>
	    <t>
	      #6a in S <xref target="ATTR-mode" format="counter"/>
	    </t>
	  </td>
	  <td>
	    <t>
	      New/revised description of the role of the "sticky bit" for
	      directories, both with respect to ACL handling and mode
	      handling.
	    </t>
	    <t>
	      Needs to be considered together with Item #62 in the ACL
	      document.
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>18</td>
	  <td>RT</td>
	  <td>
	    <t>
	      #18a in S <xref target="AUTHFA-attr" format="counter"/>
	    </t>
	    <t>
	      #18b in S <xref target="AUTHFA-two" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
	      Origially concerend with need for support of owner,
	      owner_group.	      
	    </t>
	    <t>
	      Has now been combined with item #57.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>19</td>
	  <td>CI</td>
	  <td>
	    <t>	   	   
	      #19a in S <xref target="AUTHFA-two" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
	      Revised discussion of coordination of mode and the ACL-related
	      attributes.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>20</td>
	  <td>CI</td>
	  <td>
	    <t>
	      #20 in S <xref target="ATTR-mode" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
	      More closely align ACL_based and mode-based semantics with
	      regard to SVTX.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>21</td>
	  <td>BC</td>
	  <td>
	    <t>
	      #21a in S <xref target="INTRO-term" format="counter"/>
	    </t>
	    <t>
	      #21b in S <xref target="ATTR-mode" format="counter"/>
	    </t>

	  </td>

	  <td>
	    <t>
              Introduce the concept of reverse-slope modes and deal 
	      properly with them.   The decision as to the proper
	      handling is addressed as Consensus Item #28.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>22</td>
	  <td>BC</td>
	  <td>
	    <t>
	      #22a in S <xref target="AUTHCOMM-server" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
              Revise treatment of divergences between ACL/mode authorization
	      and server behavior, dividing the treatment between cases
	      in which something authorized  is still not allowed (OK),
	      and those in which something not authorized is allowed
	      (highly problematic from a security point of view).
	    </t>
	  </td>
	</tr>
	<tr>
          <td>23</td>
	  <td>BC</td>
	  <td>
	    <t>
	      #23a in S <xref target="AUTHCOMM-ops" format="counter"/>
	    </t>
	    <t>
	      #23b in S <xref target="AUTHCOMM-client" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
	      Revise discussion of client interpretation of ACLs and the use of
	      ACCESS instead
	    </t>
	  </td>
	</tr>
	<tr>
          <td>24</td>
	  <td>BE</td>
	  <td>
	    <t>
	      #24a in S <xref target="AUTHCOMM-client" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
              Delete bogus reference.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>25</td>
	  <td>CI</td>
	  <td>
	    <t>
	      #25a in S <xref target="UINTRO-feat" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
              Revised description of co-ordination of acl and mode
	      attributes to apply to NFSv4 as a whole. While this includes
	      many aspects of the shift
	      to be more specific about the co-ordination
	      requirements including addressing apparently
	      unmotivated uses of the terms
	      "<bcp14>SHOULD</bcp14>" and "<bcp14>SHOULD NOT</bcp14>",
	      it excludes some arguably related
	      matters dealt with as Consensus Items #26 and #27.
	    </t>
	    <t>
	      Needs to be considered together with Item #63 in the ACL
	      document.
	    </t>
	  </td>
	</tr>
 	<tr>
          <td>32</td>
	  <td>BC</td>
	  <td>
	    <t>
	      #32a in S <xref target="NEGO"  format="counter"/>
	    </t>
	    <t>
	      #32b in S <xref target="NEGO-char"  format="counter"/>
	    </t>
	    <t>
	      #32c in S <xref target="IANA"  format="counter"/>
	    </t>
	    <t>
	      #32d in S <xref target="IANA-authstat"  format="counter"/>
	    </t>
	    <t>
	      #32e in S <xref target="IANA-flavors"  format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
              Expanded negotiation framework to accommodate multiple
	      transport types and security services provided on a 
	      per-connection basis, i.e. encryption and peer authentication.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>33</td>
	  <td>RT</td>
	  <td>
	    Material formerly here moved to #32.
	  </td>

	  <td>
	    <t>
              Reorganization of description of SECINFO op to apply
	      to all minor versions.  (Dropped)
	    </t>
	  </td>
	</tr>
	<tr>
          <td>34</td>
	  <td>RT</td>
	  <td>
	    Superseded by simpler treatment.
	  </td>

	  <td>
	    <t>
              Revision to NFSv4.0 SECINFO implementation section
	      (Dropped).
	    </t>
	  </td>
	</tr>
	<tr>
          <td>35</td>
	  <td>NM</td>
	  <td>
	    <t>
	      #35a in S <xref target="FUTURE-base"  format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
              Now has preliminary work on future security needs.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>36</td>
	  <td>CI</td>
	  <td>
	    <t>
	      #36a in S <xref target="SECCON-changes-diverge" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
              Threat analysis only dealing with RECOMMENDED behavior
	      regarding use of per-connection security facilities and
	      handling of AUTH_SYS.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>37</td>
	  <td>CI</td>
	  <td>
	    <t>
	      #37a in S <xref target="SECCON-changes-diverge" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
              Threat analysis only dealing with RECOMMENDED behavior
              with regard to acl support including ACL/mode coordination.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>38</td>
	  <td>CI</td>
	  <td>
	    <t>
	      #38a in S <xref target="SECCON-changes-compat" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
              Address the need to temporarily allow unsafe behavior
	      mistakenly allowed by previous specifications
	    </t>
	  </td>
	</tr>
	<tr>
          <td>39</td>
	  <td>CI</td>
	  <td>
	    <t>
	      #39a in S <xref target="SECCON-changes-authsys" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
              Define new approach to AUTH_SYS.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>40</td>
	  <td>CI</td>
	  <td>
	    <t>
	      #40a in S <xref target="SECCON-scope-levels" format="counter"/>
	    </t>
	    <t>
	      #40a in S <xref target="SECCON-scope-env" format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
              Discussion of scope for security considerations and the
	      corresponding threat analysis.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>41</td>
	  <td>CI</td>
	  <td>
	    <t>
	      #41a in S <xref target="AUTHCOMM-server" format="counter"/>
	    </t>
	    <t>
	      #41b in S <xref target="SECCON-major-data" format="counter"/>
	    </t>
	    <t>
	      #41c in S <xref target="SECCON-major-cpeer" format="counter"/>
	    </t>
	    <t>
	      #41d in S <xref target="SECCON-major-bypass"
	                      format="counter"/>
	    </t>
	    <t>
	    </t>
	  </td>

	  <td>
	    <t>
              Discuss major new security recommendations regarding
	      protection of data in flight and client peer authentication.
	      Also, covers the circumstances under which such recommendations
	      can be bypassed.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>42</td>
	  <td>RT</td>
	  <td>
	    <t>
	      #42a in S <xref target="SECTHREAT-data" format="counter"/>
	    </t>
	  </td>

	  <td rowspan="5">
	    <t>
              Former placeholders for threat analysis subsections have now
	      been superseded by new proposed subsections.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>43</td>
	  <td>RT</td>
	  <td>
	    <t>
	      #43a in S <xref target="SECTHREAT-auth-sys" format="counter"/>
	    </t>
	  </td>

	</tr>
	<tr>
          <td>44</td>
	  <td>RT</td>
	  <td>
	    <t>
	      #44a in S <xref target="SECTHREAT-auth-mapping" format="counter"/>
	    </t>
	  </td>


	</tr>
	<tr>
          <td>45</td>
	  <td>RT</td>
	  <td>
	    <t>
	      #45a in S <xref target="SECTHREAT-denial-disrupt"
	                 format="counter"/>
	    </t>
	  </td>
	</tr>

	<tr>
          <td>46</td>
	  <td>RT</td>
	  <td>
	    <t>
	      #46a in S <xref target="SECTHREAT-denial-resource"
	                      format="counter"/>
	    </t>
	  </td>

	</tr>
	<tr>
          <td>47</td>
	  <td>CI</td>
	  <td>
	    gone for now.
	  </td>

	  <td>
	    <t>
              Dubious paragraph regarding AUTH_NONE is SECINFO response
	      which should be deleted if there
	      are no compatibility issues that make that impossible.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>48</td>
	  <td>RT</td>
	  <td>
	    <t>
	      Superseded by simpler treatment.
	    </t>
	  </td>

	  <td>
	    <t>
              Missing pieces of secinfo processing algorithm that
	      didn't get done in -02.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>49</td>
	  <td>RT</td>
	  <td>
	    <t>
	      Superseded by simpler treatment.
	    </t>
	  </td>

	  <td>
	    <t>
              Secinfo processing algorithm that was expected to be
	      finished in -04.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>52</td>
	  <td>NS</td>
	  <td>
	    <t>
	      #52b in S <xref target="AUTHCOMM-server" format="counter"/>
	    </t>
	    <t>
	      #52c in S <xref target="SECCON-major-super"
	                      format="counter"/>
	    </t>
	  </td>

	  <td>
	    <t>
	      Eliminate superuser semantics as it had been, as valid by
	      implication and essentially ignoring the new format for user
	      ids.  Also, deal with the security consequences
	      of its inclusion appropriately.
   	    </t>
	  </td>
	</tr>
	<tr>
          <td>53</td>
	  <td>EV</td>
	  <td>
	    <t>
	      #53a in S <xref target="SECTHREAT-creds" format="counter"/>
	    </t>
	  </td>
	  <td>
	    <t>
	      Discussion of possible adaptation of RPCSEC_GSS/Kerberos to
	      multi-factor authentication.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>54</td>
	  <td>EV</td>
	  <td>
	    <t>
	      #54a in S <xref target="SECTHREAT-auth-sys" format="counter"/>
	    </t>
	  </td>
	  <td>
	    <t>
	      Discussion of prevention of code on a compromised client
	      from hijacking the client machine's peer authentication.
	    </t>
	  </td>
	</tr>
	<tr>
          <td>55</td>
	  <td>EV</td>
	  <td>
	    <t>
	      #55a in S <xref target="SECTHREAT-auth-sys" format="counter"/>
	    </t>
	  </td>
	  <td>
	    <t>
	      Discussion of issues with potential use of Kerberos in cloud
	      environments
	    </t>
	  </td>
	</tr>
	<tr>
          <td>56</td>
	  <td>NI</td>
	  <td>
	    <t>
	      #56a in S <xref target="INTRO-term" format="counter"/>
	    </t>
	  </td>
	  <td>
	    <t>
	      Discussion of issues related to the handling of allowed
	      variants of the NFSv4 ACL model, including subsets based on
	      the Unix ACL model.
	    </t>
	    <t>
	      Needs to be considered together with Item #64 in the ACL
	      document.
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>57</td>
	  <td>BC</td>
	  <td>
	    <t>
	      #57a in S <xref target="INTRO-term" format="counter"/>
	    </t>
	    <t>
	      #57b in S <xref target="ATTR" format="counter"/>
	    </t>
	    <t>
	      #57c in S <xref target="ATTR-idstrings" format="counter"/>
	    </t>
	    <t>
	      #57d in S <xref target="ATTR-posix" format="counter"/>
	    </t>
	    <t>
	      #57e in S <xref target="AUTHFA-attr" format="counter"/>
	    </t>
	  </td>
	  <td>
	    <t>
	      Designation of mode, owner, and owner_group as
	      <bcp14>REQUIRED</bcp14> attributes.
	    </t>
	    <t>
	      Eliminates the undue complexity and gratuitous
	      interoperability problems providing implementation
	      that do not provide POSIX authorization semantics,
	      including those with no authorization support at all.
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>58</td>
	  <td>NM</td>
	  <td>
	    <t>
	      #58a in S <xref target="ATTR" format="counter"/>
	    </t>
	    <t>
	      #58e in S <xref target="ATTR-seclabel" format="counter"/>
	    </t>
	  </td>
	  <td>
	    <t>
	      Designation of the acl, dacl, sacl, and sec_label
	      attributes as Experimental, rather than
	      <bcp14>OPTIONAL</bcp14>.
	    </t>
	    <t>
	      Note that this is separate from the possibility of
	      sufficiently clarifying the description of the acl, dacl,
	      and sacl attributes to make the Experimental designation
	      unnecessary, which will be covered as Item #XX.
	    </t>
	    <t>
	      Needs to be considered together with Item #65 in the ACL
	      document.
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>59</td>
	  <td>NM</td>
	  <td>
	    <t>
	      #59a in S <xref target="ATTR-idstrings" format="counter"/>
	    </t>
	  </td>
	  <td>
	    <t>
	      Major clarification of the handling of id strings,
	      including removal of denigration of the numeric form.
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>60</td>
	  <td>BC</td>
	  <td>
	    <t>
	      #60a in S <xref target="ATTR-idstrings" format="counter"/>
	    </t>
	  </td>
	  <td>
	    <t>
	      Addressng properly issue of special users such as root snd
	      nobody in the context of id strings.
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>66</td>
	  <td>NE</td>
	  <td>
	    <t>
	      #66a in S <xref target="AUTHFA-posix-na" format="counter"/>
	    </t>
	  </td>
	  <td>
	    <t>
	      Discussion needed of authorization semantics for access
	      to named attributes.
	    </t>
	    <t>
	      Needs to be coorinated with handling of Item #100,
	      addressed in the companion ACL document.
	    </t>
	  </td>
	</tr>
      </tbody>
    </table>

    <t>
      The following table summarizes the issues in each particular
      pending state.
    </t>
    <table>
      <thead>
	<tr>
	  <th>Type</th>
	  <th>Cnt</th>
	  <th>Issues</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td>BC</td>
	  <td>6</td>
	  <td>
	    <t>
	      21, 22, 23, 32, 57, 60
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>BE</td>
	  <td>1</td>
	  <td>
	    <t>
	      24
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>CI</td>
	  <td>11</td>
	  <td>
	    <t>
	      6, 19, 20, 25, 36, 37, 38, 39, 40, 41, 47
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>EV</td>
	  <td>3</td>
	  <td>
	    <t>
	      53, 54, 55
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>NE</td>
	  <td>1</td>
	  <td>
	    <t>
	      66
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>NI</td>
	  <td>1</td>
	  <td>
	    <t>
	      56
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>NM</td>
	  <td>3</td>
	  <td>
	    <t>
	      35, 58, 59
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>NS</td>
	  <td>1</td>
	  <td>
	    <t>
	      52
	    </t>
	  </td>
	</tr>	
	<tr>
	  <td>*All*</td>
	  <td>27</td>
	  <td>
	    <t>
	      Grand total for above table.
	    </t>
	  </td>
	</tr>

      </tbody>
    </table>
    <t>
      The following table summarizes the issues in each particular
      non-pending state..
    </t>
    <table>
      <thead>
	<tr>
	  <th>Type</th>
	  <th>Cnt</th>
	  <th>Issues</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td>CA</td>
	  <td>2</td>
	  <td>
	    <t>
	      1, 2
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>RT</td>
	  <td>9</td>
	  <td>
	    <t>
	      18, 33, 34, 42, 43, 44, 45, 46, 48
	    </t>
	  </td>
	</tr>
	<tr>
	  <td>*All*</td>
	  <td>11</td>
	  <td>
	    <t>
	      Grand total for above table.
	    </t>
	  </td>
	</tr>

      </tbody>
    </table>	
  </section>
  <section anchor="ACK" numbered="false">
    <name>Acknowledgments</name>

    <t>
      The author wishes to thank Tom Haynes for his helpful suggestion
      to deal with security for all NFSv4 minor versions in the same
      document. 
    </t>
    <t>
      The author wishes to thank Chris Inacio for pointing out
      the dificulties created by the existing handlin of name mapping.
    </t>
    <t>
      The author wishes to thank Brian Pawlowski for his helpful
      insights into the history of NFsv4 security handling.
    </t>
    <t>
      The author wishes to draw people's attention to Nico Williams'
      remark that NFSv4 security was not so bad, except that there was
      no provision for authentication of the client peer.  This
      perceptive remark, which now seems like common sense, did not seem
      so when made, but it has served as a beacon for those working
      on putting NFSv4
      security on a firmer footing.  We appreciate Nico's perceptive
      guidance.
    </t>
    <t>
      The author wishes to thank Bruce Fields for his helpful comments
      regarding ACL support which had a major role in the evolution
      of this document.
    </t>
    <t>
      The author wishes to acknowledge the important role of the authors
      of RPC-with-TLS, Chuck Lever and Trond Myklebust, in moving the
      NFS security agenda forward and thank them for all their efforts
      to improve NFS security.
    </t>
    <t>
      The author wishes to thank Chuck Lever for his many helpful
      comments about nfsv4 security issues, his explanation of many
      unclear points, and much important guidance he provided that
      is reflected in this document, including his work to streamline
      the security negotiation process by the definition of new
      pseudo-flavors.
    </t>
    <t>
      The author wishes to thank Rick Macklem for his help in 
      resolving NFSv4 security issues.  These include
      clarifying possible server policies regarding RPC-with-TLS, helping
      to clarify "owner-override semantics" and
      bringing to the Working Group's attention the possibility of
      deriving limited principal identification from client peer authentication
      while still staying within the boundaries of RPC-with-TLS.
    </t>
  </section>
</back>
</rfc>

